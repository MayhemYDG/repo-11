// Code generated - EDITING IS FUTILE. DO NOT EDIT.
//
// Generated by pipeline:
//     terraform
// Using jennies:
//     TerraformDataSourceJenny
//     LatestJenny
//
// Run 'go generate ./' from repository root to regenerate.

package provider

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure that the imports are used to avoid compiler errors.
var _ attr.Value
var _ diag.Diagnostic

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ datasource.DataSource              = &CoreDashboardDataSource{}
	_ datasource.DataSourceWithConfigure = &CoreDashboardDataSource{}
)

func NewCoreDashboardDataSource() datasource.DataSource {
	return &CoreDashboardDataSource{}
}

// CoreDashboardDataSource defines the data source implementation.
type CoreDashboardDataSource struct{}

type CoreDashboardDataSourceModel_Time struct {
	From types.String `tfsdk:"from"`
	To   types.String `tfsdk:"to"`
}

func (m CoreDashboardDataSourceModel_Time) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Time struct {
		From string `json:"from"`
		To   string `json:"to"`
	}

	m = m.ApplyDefaults()
	attr_from := m.From.ValueString()
	attr_to := m.To.ValueString()

	model := &jsonCoreDashboardDataSourceModel_Time{
		From: attr_from,
		To:   attr_to,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Time) ApplyDefaults() CoreDashboardDataSourceModel_Time {
	if m.From.IsNull() {
		m.From = types.StringValue(`now-6h`)
	}
	if m.To.IsNull() {
		m.To = types.StringValue(`now`)
	}
	return m
}

type CoreDashboardDataSourceModel_Timepicker struct {
	Hidden           types.Bool `tfsdk:"hidden"`
	RefreshIntervals types.List `tfsdk:"refresh_intervals"`
	Collapse         types.Bool `tfsdk:"collapse"`
	Enable           types.Bool `tfsdk:"enable"`
	TimeOptions      types.List `tfsdk:"time_options"`
}

func (m CoreDashboardDataSourceModel_Timepicker) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Timepicker struct {
		Hidden           bool     `json:"hidden"`
		RefreshIntervals []string `json:"refresh_intervals,omitempty"`
		Collapse         bool     `json:"collapse"`
		Enable           bool     `json:"enable"`
		TimeOptions      []string `json:"time_options,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_hidden := m.Hidden.ValueBool()
	attr_refresh_intervals := []string{}
	for _, v := range m.RefreshIntervals.Elements() {
		attr_refresh_intervals = append(attr_refresh_intervals, v.(types.String).ValueString())
	}
	attr_collapse := m.Collapse.ValueBool()
	attr_enable := m.Enable.ValueBool()
	attr_time_options := []string{}
	for _, v := range m.TimeOptions.Elements() {
		attr_time_options = append(attr_time_options, v.(types.String).ValueString())
	}

	model := &jsonCoreDashboardDataSourceModel_Timepicker{
		Hidden:           attr_hidden,
		RefreshIntervals: attr_refresh_intervals,
		Collapse:         attr_collapse,
		Enable:           attr_enable,
		TimeOptions:      attr_time_options,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Timepicker) ApplyDefaults() CoreDashboardDataSourceModel_Timepicker {
	if m.Hidden.IsNull() {
		m.Hidden = types.BoolValue(false)
	}
	if len(m.RefreshIntervals.Elements()) == 0 {
		m.RefreshIntervals, _ = types.ListValue(types.StringType, []attr.Value{})
	}
	if m.Collapse.IsNull() {
		m.Collapse = types.BoolValue(false)
	}
	if m.Enable.IsNull() {
		m.Enable = types.BoolValue(true)
	}
	if len(m.TimeOptions.Elements()) == 0 {
		m.TimeOptions, _ = types.ListValue(types.StringType, []attr.Value{})
	}
	return m
}

type CoreDashboardDataSourceModel_Templating_List_Error struct {
}

func (m CoreDashboardDataSourceModel_Templating_List_Error) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Templating_List_Error struct {
	}

	m = m.ApplyDefaults()

	model := &jsonCoreDashboardDataSourceModel_Templating_List_Error{}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Templating_List_Error) ApplyDefaults() CoreDashboardDataSourceModel_Templating_List_Error {

	return m
}

type CoreDashboardDataSourceModel_Templating_List_Datasource struct {
	Type types.String `tfsdk:"type"`
	Uid  types.String `tfsdk:"uid"`
}

func (m CoreDashboardDataSourceModel_Templating_List_Datasource) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Templating_List_Datasource struct {
		Type *string `json:"type,omitempty"`
		Uid  *string `json:"uid,omitempty"`
	}

	m = m.ApplyDefaults()
	var attr_type *string
	if !m.Type.IsNull() && !m.Type.IsUnknown() {
		tmp := m.Type.ValueString()
		attr_type = &tmp
	}
	var attr_uid *string
	if !m.Uid.IsNull() && !m.Uid.IsUnknown() {
		tmp := m.Uid.ValueString()
		attr_uid = &tmp
	}

	model := &jsonCoreDashboardDataSourceModel_Templating_List_Datasource{
		Type: attr_type,
		Uid:  attr_uid,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Templating_List_Datasource) ApplyDefaults() CoreDashboardDataSourceModel_Templating_List_Datasource {

	return m
}

type CoreDashboardDataSourceModel_Templating_List struct {
	Type         types.String                                             `tfsdk:"type"`
	Name         types.String                                             `tfsdk:"name"`
	Label        types.String                                             `tfsdk:"label"`
	RootStateKey types.String                                             `tfsdk:"root_state_key"`
	Global       types.Bool                                               `tfsdk:"global"`
	Hide         types.Int64                                              `tfsdk:"hide"`
	SkipUrlSync  types.Bool                                               `tfsdk:"skip_url_sync"`
	Index        types.Int64                                              `tfsdk:"index"`
	State        types.String                                             `tfsdk:"state"`
	Error        *CoreDashboardDataSourceModel_Templating_List_Error      `tfsdk:"error"`
	Description  types.String                                             `tfsdk:"description"`
	Query        types.String                                             `tfsdk:"query"`
	Datasource   *CoreDashboardDataSourceModel_Templating_List_Datasource `tfsdk:"datasource"`
}

func (m CoreDashboardDataSourceModel_Templating_List) GetAttrQuery() interface{} {
	var attr interface{}
	var err error

	err = json.Unmarshal([]byte(m.Query.ValueString()), &attr)
	if err == nil {
		return attr
	}

	return m.Query.ValueString()
}

func (m CoreDashboardDataSourceModel_Templating_List) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Templating_List struct {
		Type         string      `json:"type"`
		Name         string      `json:"name"`
		Label        *string     `json:"label,omitempty"`
		RootStateKey *string     `json:"rootStateKey,omitempty"`
		Global       bool        `json:"global"`
		Hide         int64       `json:"hide"`
		SkipUrlSync  bool        `json:"skipUrlSync"`
		Index        int64       `json:"index"`
		State        string      `json:"state"`
		Error        interface{} `json:"error,omitempty"`
		Description  *string     `json:"description,omitempty"`
		Query        interface{} `json:"query,omitempty"`
		Datasource   interface{} `json:"datasource,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_type := m.Type.ValueString()
	attr_name := m.Name.ValueString()
	var attr_label *string
	if !m.Label.IsNull() && !m.Label.IsUnknown() {
		tmp := m.Label.ValueString()
		attr_label = &tmp
	}
	var attr_rootstatekey *string
	if !m.RootStateKey.IsNull() && !m.RootStateKey.IsUnknown() {
		tmp := m.RootStateKey.ValueString()
		attr_rootstatekey = &tmp
	}
	attr_global := m.Global.ValueBool()
	attr_hide := m.Hide.ValueInt64()
	attr_skipurlsync := m.SkipUrlSync.ValueBool()
	attr_index := m.Index.ValueInt64()
	attr_state := m.State.ValueString()
	var attr_error interface{}
	if m.Error != nil {
		attr_error = m.Error
	}
	var attr_description *string
	if !m.Description.IsNull() && !m.Description.IsUnknown() {
		tmp := m.Description.ValueString()
		attr_description = &tmp
	}
	attr_query := m.GetAttrQuery()
	var attr_datasource interface{}
	if m.Datasource != nil {
		attr_datasource = m.Datasource
	}

	model := &jsonCoreDashboardDataSourceModel_Templating_List{
		Type:         attr_type,
		Name:         attr_name,
		Label:        attr_label,
		RootStateKey: attr_rootstatekey,
		Global:       attr_global,
		Hide:         attr_hide,
		SkipUrlSync:  attr_skipurlsync,
		Index:        attr_index,
		State:        attr_state,
		Error:        attr_error,
		Description:  attr_description,
		Query:        attr_query,
		Datasource:   attr_datasource,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Templating_List) ApplyDefaults() CoreDashboardDataSourceModel_Templating_List {
	if m.Global.IsNull() {
		m.Global = types.BoolValue(false)
	}
	if m.SkipUrlSync.IsNull() {
		m.SkipUrlSync = types.BoolValue(false)
	}
	if m.Index.IsNull() {
		m.Index = types.Int64Value(-1)
	}
	return m
}

type CoreDashboardDataSourceModel_Templating struct {
	List []CoreDashboardDataSourceModel_Templating_List `tfsdk:"list"`
}

func (m CoreDashboardDataSourceModel_Templating) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Templating struct {
		List []interface{} `json:"list,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_list := []interface{}{}
	for _, v := range m.List {
		attr_list = append(attr_list, v)
	}

	model := &jsonCoreDashboardDataSourceModel_Templating{
		List: attr_list,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Templating) ApplyDefaults() CoreDashboardDataSourceModel_Templating {

	return m
}

type CoreDashboardDataSourceModel_Annotations_List_Datasource struct {
	Type types.String `tfsdk:"type"`
	Uid  types.String `tfsdk:"uid"`
}

func (m CoreDashboardDataSourceModel_Annotations_List_Datasource) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Annotations_List_Datasource struct {
		Type *string `json:"type,omitempty"`
		Uid  *string `json:"uid,omitempty"`
	}

	m = m.ApplyDefaults()
	var attr_type *string
	if !m.Type.IsNull() && !m.Type.IsUnknown() {
		tmp := m.Type.ValueString()
		attr_type = &tmp
	}
	var attr_uid *string
	if !m.Uid.IsNull() && !m.Uid.IsUnknown() {
		tmp := m.Uid.ValueString()
		attr_uid = &tmp
	}

	model := &jsonCoreDashboardDataSourceModel_Annotations_List_Datasource{
		Type: attr_type,
		Uid:  attr_uid,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Annotations_List_Datasource) ApplyDefaults() CoreDashboardDataSourceModel_Annotations_List_Datasource {

	return m
}

type CoreDashboardDataSourceModel_Annotations_List_Filter struct {
	Exclude types.Bool `tfsdk:"exclude"`
	Ids     types.List `tfsdk:"ids"`
}

func (m CoreDashboardDataSourceModel_Annotations_List_Filter) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Annotations_List_Filter struct {
		Exclude *bool   `json:"exclude,omitempty"`
		Ids     []int64 `json:"ids,omitempty"`
	}

	m = m.ApplyDefaults()
	var attr_exclude *bool
	if !m.Exclude.IsNull() && !m.Exclude.IsUnknown() {
		tmp := m.Exclude.ValueBool()
		attr_exclude = &tmp
	}
	attr_ids := []int64{}
	for _, v := range m.Ids.Elements() {
		attr_ids = append(attr_ids, v.(types.Int64).ValueInt64())
	}

	model := &jsonCoreDashboardDataSourceModel_Annotations_List_Filter{
		Exclude: attr_exclude,
		Ids:     attr_ids,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Annotations_List_Filter) ApplyDefaults() CoreDashboardDataSourceModel_Annotations_List_Filter {
	if m.Exclude.IsNull() {
		m.Exclude = types.BoolValue(false)
	}
	if len(m.Ids.Elements()) == 0 {
		m.Ids, _ = types.ListValue(types.Int64Type, []attr.Value{})
	}
	return m
}

type CoreDashboardDataSourceModel_Annotations_List_Target struct {
	Limit    types.Int64  `tfsdk:"limit"`
	MatchAny types.Bool   `tfsdk:"match_any"`
	Tags     types.List   `tfsdk:"tags"`
	Type     types.String `tfsdk:"type"`
}

func (m CoreDashboardDataSourceModel_Annotations_List_Target) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Annotations_List_Target struct {
		Limit    int64    `json:"limit"`
		MatchAny bool     `json:"matchAny"`
		Tags     []string `json:"tags,omitempty"`
		Type     string   `json:"type"`
	}

	m = m.ApplyDefaults()
	attr_limit := m.Limit.ValueInt64()
	attr_matchany := m.MatchAny.ValueBool()
	attr_tags := []string{}
	for _, v := range m.Tags.Elements() {
		attr_tags = append(attr_tags, v.(types.String).ValueString())
	}
	attr_type := m.Type.ValueString()

	model := &jsonCoreDashboardDataSourceModel_Annotations_List_Target{
		Limit:    attr_limit,
		MatchAny: attr_matchany,
		Tags:     attr_tags,
		Type:     attr_type,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Annotations_List_Target) ApplyDefaults() CoreDashboardDataSourceModel_Annotations_List_Target {
	if len(m.Tags.Elements()) == 0 {
		m.Tags, _ = types.ListValue(types.StringType, []attr.Value{})
	}
	return m
}

type CoreDashboardDataSourceModel_Annotations_List struct {
	Name       types.String                                              `tfsdk:"name"`
	Datasource *CoreDashboardDataSourceModel_Annotations_List_Datasource `tfsdk:"datasource"`
	Enable     types.Bool                                                `tfsdk:"enable"`
	Hide       types.Bool                                                `tfsdk:"hide"`
	IconColor  types.String                                              `tfsdk:"icon_color"`
	Filter     *CoreDashboardDataSourceModel_Annotations_List_Filter     `tfsdk:"filter"`
	Target     *CoreDashboardDataSourceModel_Annotations_List_Target     `tfsdk:"target"`
	Type       types.String                                              `tfsdk:"type"`
}

func (m CoreDashboardDataSourceModel_Annotations_List) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Annotations_List struct {
		Name       string      `json:"name"`
		Datasource interface{} `json:"datasource,omitempty"`
		Enable     bool        `json:"enable"`
		Hide       *bool       `json:"hide,omitempty"`
		IconColor  string      `json:"iconColor"`
		Filter     interface{} `json:"filter,omitempty"`
		Target     interface{} `json:"target,omitempty"`
		Type       *string     `json:"type,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_name := m.Name.ValueString()
	var attr_datasource interface{}
	if m.Datasource != nil {
		attr_datasource = m.Datasource
	}
	attr_enable := m.Enable.ValueBool()
	var attr_hide *bool
	if !m.Hide.IsNull() && !m.Hide.IsUnknown() {
		tmp := m.Hide.ValueBool()
		attr_hide = &tmp
	}
	attr_iconcolor := m.IconColor.ValueString()
	var attr_filter interface{}
	if m.Filter != nil {
		attr_filter = m.Filter
	}
	var attr_target interface{}
	if m.Target != nil {
		attr_target = m.Target
	}
	var attr_type *string
	if !m.Type.IsNull() && !m.Type.IsUnknown() {
		tmp := m.Type.ValueString()
		attr_type = &tmp
	}

	model := &jsonCoreDashboardDataSourceModel_Annotations_List{
		Name:       attr_name,
		Datasource: attr_datasource,
		Enable:     attr_enable,
		Hide:       attr_hide,
		IconColor:  attr_iconcolor,
		Filter:     attr_filter,
		Target:     attr_target,
		Type:       attr_type,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Annotations_List) ApplyDefaults() CoreDashboardDataSourceModel_Annotations_List {
	if m.Enable.IsNull() {
		m.Enable = types.BoolValue(true)
	}
	if m.Hide.IsNull() {
		m.Hide = types.BoolValue(false)
	}
	return m
}

type CoreDashboardDataSourceModel_Annotations struct {
	List []CoreDashboardDataSourceModel_Annotations_List `tfsdk:"list"`
}

func (m CoreDashboardDataSourceModel_Annotations) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Annotations struct {
		List []interface{} `json:"list,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_list := []interface{}{}
	for _, v := range m.List {
		attr_list = append(attr_list, v)
	}

	model := &jsonCoreDashboardDataSourceModel_Annotations{
		List: attr_list,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Annotations) ApplyDefaults() CoreDashboardDataSourceModel_Annotations {

	return m
}

type CoreDashboardDataSourceModel_Links struct {
	Title       types.String `tfsdk:"title"`
	Type        types.String `tfsdk:"type"`
	Icon        types.String `tfsdk:"icon"`
	Tooltip     types.String `tfsdk:"tooltip"`
	Url         types.String `tfsdk:"url"`
	Tags        types.List   `tfsdk:"tags"`
	AsDropdown  types.Bool   `tfsdk:"as_dropdown"`
	TargetBlank types.Bool   `tfsdk:"target_blank"`
	IncludeVars types.Bool   `tfsdk:"include_vars"`
	KeepTime    types.Bool   `tfsdk:"keep_time"`
}

func (m CoreDashboardDataSourceModel_Links) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Links struct {
		Title       string   `json:"title"`
		Type        string   `json:"type"`
		Icon        string   `json:"icon"`
		Tooltip     string   `json:"tooltip"`
		Url         string   `json:"url"`
		Tags        []string `json:"tags,omitempty"`
		AsDropdown  bool     `json:"asDropdown"`
		TargetBlank bool     `json:"targetBlank"`
		IncludeVars bool     `json:"includeVars"`
		KeepTime    bool     `json:"keepTime"`
	}

	m = m.ApplyDefaults()
	attr_title := m.Title.ValueString()
	attr_type := m.Type.ValueString()
	attr_icon := m.Icon.ValueString()
	attr_tooltip := m.Tooltip.ValueString()
	attr_url := m.Url.ValueString()
	attr_tags := []string{}
	for _, v := range m.Tags.Elements() {
		attr_tags = append(attr_tags, v.(types.String).ValueString())
	}
	attr_asdropdown := m.AsDropdown.ValueBool()
	attr_targetblank := m.TargetBlank.ValueBool()
	attr_includevars := m.IncludeVars.ValueBool()
	attr_keeptime := m.KeepTime.ValueBool()

	model := &jsonCoreDashboardDataSourceModel_Links{
		Title:       attr_title,
		Type:        attr_type,
		Icon:        attr_icon,
		Tooltip:     attr_tooltip,
		Url:         attr_url,
		Tags:        attr_tags,
		AsDropdown:  attr_asdropdown,
		TargetBlank: attr_targetblank,
		IncludeVars: attr_includevars,
		KeepTime:    attr_keeptime,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Links) ApplyDefaults() CoreDashboardDataSourceModel_Links {
	if len(m.Tags.Elements()) == 0 {
		m.Tags, _ = types.ListValue(types.StringType, []attr.Value{})
	}
	if m.AsDropdown.IsNull() {
		m.AsDropdown = types.BoolValue(false)
	}
	if m.TargetBlank.IsNull() {
		m.TargetBlank = types.BoolValue(false)
	}
	if m.IncludeVars.IsNull() {
		m.IncludeVars = types.BoolValue(false)
	}
	if m.KeepTime.IsNull() {
		m.KeepTime = types.BoolValue(false)
	}
	return m
}

type CoreDashboardDataSourceModel_Snapshot struct {
	Created     types.String `tfsdk:"created"`
	Expires     types.String `tfsdk:"expires"`
	External    types.Bool   `tfsdk:"external"`
	ExternalUrl types.String `tfsdk:"external_url"`
	Key         types.String `tfsdk:"key"`
	Name        types.String `tfsdk:"name"`
	OrgId       types.Int64  `tfsdk:"org_id"`
	Updated     types.String `tfsdk:"updated"`
	Url         types.String `tfsdk:"url"`
	UserId      types.Int64  `tfsdk:"user_id"`
}

func (m CoreDashboardDataSourceModel_Snapshot) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Snapshot struct {
		Created     string  `json:"created"`
		Expires     string  `json:"expires"`
		External    bool    `json:"external"`
		ExternalUrl string  `json:"externalUrl"`
		Key         string  `json:"key"`
		Name        string  `json:"name"`
		OrgId       int64   `json:"orgId"`
		Updated     string  `json:"updated"`
		Url         *string `json:"url,omitempty"`
		UserId      int64   `json:"userId"`
	}

	m = m.ApplyDefaults()
	attr_created := m.Created.ValueString()
	attr_expires := m.Expires.ValueString()
	attr_external := m.External.ValueBool()
	attr_externalurl := m.ExternalUrl.ValueString()
	attr_key := m.Key.ValueString()
	attr_name := m.Name.ValueString()
	attr_orgid := m.OrgId.ValueInt64()
	attr_updated := m.Updated.ValueString()
	var attr_url *string
	if !m.Url.IsNull() && !m.Url.IsUnknown() {
		tmp := m.Url.ValueString()
		attr_url = &tmp
	}
	attr_userid := m.UserId.ValueInt64()

	model := &jsonCoreDashboardDataSourceModel_Snapshot{
		Created:     attr_created,
		Expires:     attr_expires,
		External:    attr_external,
		ExternalUrl: attr_externalurl,
		Key:         attr_key,
		Name:        attr_name,
		OrgId:       attr_orgid,
		Updated:     attr_updated,
		Url:         attr_url,
		UserId:      attr_userid,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Snapshot) ApplyDefaults() CoreDashboardDataSourceModel_Snapshot {

	return m
}

type CoreDashboardDataSourceModel struct {
	RenderedJSON         types.String                              `tfsdk:"rendered_json"`
	Uid                  types.String                              `tfsdk:"uid"`
	Title                types.String                              `tfsdk:"title"`
	Description          types.String                              `tfsdk:"description"`
	Revision             types.Int64                               `tfsdk:"revision"`
	GnetId               types.String                              `tfsdk:"gnet_id"`
	Tags                 types.List                                `tfsdk:"tags"`
	Style                types.String                              `tfsdk:"style"`
	Timezone             types.String                              `tfsdk:"timezone"`
	Editable             types.Bool                                `tfsdk:"editable"`
	GraphTooltip         types.Int64                               `tfsdk:"graph_tooltip"`
	Time                 *CoreDashboardDataSourceModel_Time        `tfsdk:"time"`
	Timepicker           *CoreDashboardDataSourceModel_Timepicker  `tfsdk:"timepicker"`
	FiscalYearStartMonth types.Int64                               `tfsdk:"fiscal_year_start_month"`
	LiveNow              types.Bool                                `tfsdk:"live_now"`
	WeekStart            types.String                              `tfsdk:"week_start"`
	Refresh              types.String                              `tfsdk:"refresh"`
	SchemaVersion        types.Int64                               `tfsdk:"schema_version"`
	Version              types.Int64                               `tfsdk:"version"`
	Panels               types.List                                `tfsdk:"panels"`
	Templating           *CoreDashboardDataSourceModel_Templating  `tfsdk:"templating"`
	Annotations          *CoreDashboardDataSourceModel_Annotations `tfsdk:"annotations"`
	Links                []CoreDashboardDataSourceModel_Links      `tfsdk:"links"`
	Snapshot             *CoreDashboardDataSourceModel_Snapshot    `tfsdk:"snapshot"`
}

func (m CoreDashboardDataSourceModel) GetAttrRefresh() interface{} {
	var attr interface{}
	var err error

	attr, err = strconv.ParseBool(m.Refresh.ValueString())
	if err == nil {
		return attr
	}

	return m.Refresh.ValueString()
}

func (m CoreDashboardDataSourceModel) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel struct {
		Uid                  *string       `json:"uid,omitempty"`
		Title                *string       `json:"title,omitempty"`
		Description          *string       `json:"description,omitempty"`
		Revision             *int64        `json:"revision,omitempty"`
		GnetId               *string       `json:"gnetId,omitempty"`
		Tags                 []string      `json:"tags,omitempty"`
		Style                string        `json:"style"`
		Timezone             *string       `json:"timezone,omitempty"`
		Editable             bool          `json:"editable"`
		GraphTooltip         int64         `json:"graphTooltip"`
		Time                 interface{}   `json:"time,omitempty"`
		Timepicker           interface{}   `json:"timepicker,omitempty"`
		FiscalYearStartMonth *int64        `json:"fiscalYearStartMonth,omitempty"`
		LiveNow              *bool         `json:"liveNow,omitempty"`
		WeekStart            *string       `json:"weekStart,omitempty"`
		Refresh              interface{}   `json:"refresh,omitempty"`
		SchemaVersion        int64         `json:"schemaVersion"`
		Version              *int64        `json:"version,omitempty"`
		Panels               []string      `json:"panels,omitempty"`
		Templating           interface{}   `json:"templating,omitempty"`
		Annotations          interface{}   `json:"annotations,omitempty"`
		Links                []interface{} `json:"links,omitempty"`
		Snapshot             interface{}   `json:"snapshot,omitempty"`
	}

	m = m.ApplyDefaults()
	var attr_uid *string
	if !m.Uid.IsNull() && !m.Uid.IsUnknown() {
		tmp := m.Uid.ValueString()
		attr_uid = &tmp
	}
	var attr_title *string
	if !m.Title.IsNull() && !m.Title.IsUnknown() {
		tmp := m.Title.ValueString()
		attr_title = &tmp
	}
	var attr_description *string
	if !m.Description.IsNull() && !m.Description.IsUnknown() {
		tmp := m.Description.ValueString()
		attr_description = &tmp
	}
	var attr_revision *int64
	if !m.Revision.IsNull() && !m.Revision.IsUnknown() {
		tmp := m.Revision.ValueInt64()
		attr_revision = &tmp
	}
	var attr_gnetid *string
	if !m.GnetId.IsNull() && !m.GnetId.IsUnknown() {
		tmp := m.GnetId.ValueString()
		attr_gnetid = &tmp
	}
	attr_tags := []string{}
	for _, v := range m.Tags.Elements() {
		attr_tags = append(attr_tags, v.(types.String).ValueString())
	}
	attr_style := m.Style.ValueString()
	var attr_timezone *string
	if !m.Timezone.IsNull() && !m.Timezone.IsUnknown() {
		tmp := m.Timezone.ValueString()
		attr_timezone = &tmp
	}
	attr_editable := m.Editable.ValueBool()
	attr_graphtooltip := m.GraphTooltip.ValueInt64()
	var attr_time interface{}
	if m.Time != nil {
		attr_time = m.Time
	}
	var attr_timepicker interface{}
	if m.Timepicker != nil {
		attr_timepicker = m.Timepicker
	}
	var attr_fiscalyearstartmonth *int64
	if !m.FiscalYearStartMonth.IsNull() && !m.FiscalYearStartMonth.IsUnknown() {
		tmp := m.FiscalYearStartMonth.ValueInt64()
		attr_fiscalyearstartmonth = &tmp
	}
	var attr_livenow *bool
	if !m.LiveNow.IsNull() && !m.LiveNow.IsUnknown() {
		tmp := m.LiveNow.ValueBool()
		attr_livenow = &tmp
	}
	var attr_weekstart *string
	if !m.WeekStart.IsNull() && !m.WeekStart.IsUnknown() {
		tmp := m.WeekStart.ValueString()
		attr_weekstart = &tmp
	}
	attr_refresh := m.GetAttrRefresh()
	attr_schemaversion := m.SchemaVersion.ValueInt64()
	var attr_version *int64
	if !m.Version.IsNull() && !m.Version.IsUnknown() {
		tmp := m.Version.ValueInt64()
		attr_version = &tmp
	}
	attr_panels := []string{}
	for _, v := range m.Panels.Elements() {
		attr_panels = append(attr_panels, v.(types.String).ValueString())
	}
	var attr_templating interface{}
	if m.Templating != nil {
		attr_templating = m.Templating
	}
	var attr_annotations interface{}
	if m.Annotations != nil {
		attr_annotations = m.Annotations
	}
	attr_links := []interface{}{}
	for _, v := range m.Links {
		attr_links = append(attr_links, v)
	}
	var attr_snapshot interface{}
	if m.Snapshot != nil {
		attr_snapshot = m.Snapshot
	}

	model := &jsonCoreDashboardDataSourceModel{
		Uid:                  attr_uid,
		Title:                attr_title,
		Description:          attr_description,
		Revision:             attr_revision,
		GnetId:               attr_gnetid,
		Tags:                 attr_tags,
		Style:                attr_style,
		Timezone:             attr_timezone,
		Editable:             attr_editable,
		GraphTooltip:         attr_graphtooltip,
		Time:                 attr_time,
		Timepicker:           attr_timepicker,
		FiscalYearStartMonth: attr_fiscalyearstartmonth,
		LiveNow:              attr_livenow,
		WeekStart:            attr_weekstart,
		Refresh:              attr_refresh,
		SchemaVersion:        attr_schemaversion,
		Version:              attr_version,
		Panels:               attr_panels,
		Templating:           attr_templating,
		Annotations:          attr_annotations,
		Links:                attr_links,
		Snapshot:             attr_snapshot,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel) ApplyDefaults() CoreDashboardDataSourceModel {
	if len(m.Tags.Elements()) == 0 {
		m.Tags, _ = types.ListValue(types.StringType, []attr.Value{})
	}
	if m.Style.IsNull() {
		m.Style = types.StringValue(`dark`)
	}
	if m.Timezone.IsNull() {
		m.Timezone = types.StringValue(`browser`)
	}
	if m.Editable.IsNull() {
		m.Editable = types.BoolValue(true)
	}
	if m.GraphTooltip.IsNull() {
		m.GraphTooltip = types.Int64Value(0)
	}
	if m.FiscalYearStartMonth.IsNull() {
		m.FiscalYearStartMonth = types.Int64Value(0)
	}
	if m.SchemaVersion.IsNull() {
		m.SchemaVersion = types.Int64Value(36)
	}
	if len(m.Panels.Elements()) == 0 {
		m.Panels, _ = types.ListValue(types.StringType, []attr.Value{})
	}
	return m
}

func (d *CoreDashboardDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_core_dashboard"
}

func (d *CoreDashboardDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"uid": schema.StringAttribute{
				MarkdownDescription: `Unique dashboard identifier that can be generated by anyone. string (8-40)`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"title": schema.StringAttribute{
				MarkdownDescription: `Title of dashboard.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: `Description of dashboard.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"revision": schema.Int64Attribute{
				MarkdownDescription: `This property should only be used in dashboards defined by plugins.  It is a quick check
to see if the version has changed since the last time.  Unclear why using the version property
is insufficient.`,
				Computed: false,
				Optional: true,
				Required: false,
			},
			"gnet_id": schema.StringAttribute{
				MarkdownDescription: `ID of a dashboard imported from the https://grafana.com/grafana/dashboards/ portal`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"tags": schema.ListAttribute{
				MarkdownDescription: `Tags associated with dashboard.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
				ElementType:         types.StringType,
			},
			"style": schema.StringAttribute{
				MarkdownDescription: `Theme of dashboard. Defaults to "dark".`,
				Computed:            true,
				Optional:            true,
				Required:            false,
			},
			"timezone": schema.StringAttribute{
				MarkdownDescription: `Timezone of dashboard. Accepted values are IANA TZDB zone ID or "browser" or "utc". Defaults to "browser".`,
				Computed:            true,
				Optional:            true,
				Required:            false,
			},
			"editable": schema.BoolAttribute{
				MarkdownDescription: `Whether a dashboard is editable or not. Defaults to true.`,
				Computed:            true,
				Optional:            true,
				Required:            false,
			},
			"graph_tooltip": schema.Int64Attribute{
				MarkdownDescription: `Configuration of dashboard cursor sync behavior.
Accepted values are 0 (sync turned off), 1 (shared crosshair), 2 (shared crosshair and tooltip). Defaults to 0.`,
				Computed: true,
				Optional: true,
				Required: false,
			},
			"time": schema.SingleNestedAttribute{
				MarkdownDescription: `Time range for dashboard.
Accepted values are relative time strings like {from: 'now-6h', to: 'now'} or absolute time strings like {from: '2020-07-10T08:00:00.000Z', to: '2020-07-10T14:00:00.000Z'}.`,
				Computed: true,
				Optional: true,
				Required: false,
				Attributes: map[string]schema.Attribute{
					"from": schema.StringAttribute{
						MarkdownDescription: ` Defaults to "now-6h".`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"to": schema.StringAttribute{
						MarkdownDescription: ` Defaults to "now".`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
				},
			},
			"timepicker": schema.SingleNestedAttribute{
				MarkdownDescription: `Configuration of the time picker shown at the top of a dashboard.`,
				Computed:            true,
				Optional:            true,
				Required:            false,
				Attributes: map[string]schema.Attribute{
					"hidden": schema.BoolAttribute{
						MarkdownDescription: `Whether timepicker is visible or not. Defaults to false.`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"refresh_intervals": schema.ListAttribute{
						MarkdownDescription: `Interval options available in the refresh picker dropdown.`,
						Computed:            false,
						Optional:            true,
						Required:            false,
						ElementType:         types.StringType,
					},
					"collapse": schema.BoolAttribute{
						MarkdownDescription: `Whether timepicker is collapsed or not. Has no effect on provisioned dashboard. Defaults to false.`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"enable": schema.BoolAttribute{
						MarkdownDescription: `Whether timepicker is enabled or not. Has no effect on provisioned dashboard. Defaults to true.`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"time_options": schema.ListAttribute{
						MarkdownDescription: `Selectable options available in the time picker dropdown. Has no effect on provisioned dashboard.`,
						Computed:            false,
						Optional:            true,
						Required:            false,
						ElementType:         types.StringType,
					},
				},
			},
			"fiscal_year_start_month": schema.Int64Attribute{
				MarkdownDescription: `The month that the fiscal year starts on.  0 = January, 11 = December. Defaults to 0.`,
				Computed:            true,
				Optional:            true,
				Required:            false,
			},
			"live_now": schema.BoolAttribute{
				MarkdownDescription: `When set to true, the dashboard will redraw panels at an interval matching the pixel width.
This will keep data "moving left" regardless of the query refresh rate.  This setting helps
avoid dashboards presenting stale live data`,
				Computed: false,
				Optional: true,
				Required: false,
			},
			"week_start": schema.StringAttribute{
				MarkdownDescription: `Day when the week starts. Expressed by the name of the day in lowercase, e.g. "monday".`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"refresh": schema.StringAttribute{
				MarkdownDescription: `Refresh rate of dashboard. Represented via interval string, e.g. "5s", "1m", "1h", "1d".`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"schema_version": schema.Int64Attribute{
				MarkdownDescription: `Version of the JSON schema, incremented each time a Grafana update brings
changes to said schema.
TODO this is the existing schema numbering system. It will be replaced by Thema's themaVersion. Defaults to 36.`,
				Computed: true,
				Optional: true,
				Required: false,
			},
			"version": schema.Int64Attribute{
				MarkdownDescription: `Version of the dashboard, incremented each time the dashboard is updated.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"panels": schema.ListAttribute{
				MarkdownDescription: ``,
				Computed:            false,
				Optional:            true,
				Required:            false,
				ElementType:         types.StringType,
			},
			"templating": schema.SingleNestedAttribute{
				MarkdownDescription: `Contains the list of configured template variables with their saved values along with some other metadata`,
				Computed:            true,
				Optional:            true,
				Required:            false,
				Attributes: map[string]schema.Attribute{
					"list": schema.ListNestedAttribute{
						MarkdownDescription: ``,
						Computed:            false,
						Optional:            true,
						Required:            false,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"type": schema.StringAttribute{
									MarkdownDescription: ``,
									Computed:            false,
									Optional:            false,
									Required:            true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: ``,
									Computed:            false,
									Optional:            false,
									Required:            true,
								},
								"label": schema.StringAttribute{
									MarkdownDescription: ``,
									Computed:            false,
									Optional:            true,
									Required:            false,
								},
								"root_state_key": schema.StringAttribute{
									MarkdownDescription: ``,
									Computed:            false,
									Optional:            true,
									Required:            false,
								},
								"global": schema.BoolAttribute{
									MarkdownDescription: ` Defaults to false.`,
									Computed:            true,
									Optional:            true,
									Required:            false,
								},
								"hide": schema.Int64Attribute{
									MarkdownDescription: ``,
									Computed:            false,
									Optional:            false,
									Required:            true,
								},
								"skip_url_sync": schema.BoolAttribute{
									MarkdownDescription: ` Defaults to false.`,
									Computed:            true,
									Optional:            true,
									Required:            false,
								},
								"index": schema.Int64Attribute{
									MarkdownDescription: ` Defaults to -1.`,
									Computed:            true,
									Optional:            true,
									Required:            false,
								},
								"state": schema.StringAttribute{
									MarkdownDescription: ``,
									Computed:            false,
									Optional:            false,
									Required:            true,
								},
								"error": schema.SingleNestedAttribute{
									MarkdownDescription: ``,
									Computed:            true,
									Optional:            true,
									Required:            false,
								},
								"description": schema.StringAttribute{
									MarkdownDescription: ``,
									Computed:            false,
									Optional:            true,
									Required:            false,
								},
								"query": schema.StringAttribute{
									MarkdownDescription: `JSON-encoded string. TODO: Move this into a separated QueryVariableModel type`,
									Computed:            false,
									Optional:            true,
									Required:            false,
								},
								"datasource": schema.SingleNestedAttribute{
									MarkdownDescription: ``,
									Computed:            true,
									Optional:            true,
									Required:            false,
									Attributes: map[string]schema.Attribute{
										"type": schema.StringAttribute{
											MarkdownDescription: `The plugin type-id`,
											Computed:            false,
											Optional:            true,
											Required:            false,
										},
										"uid": schema.StringAttribute{
											MarkdownDescription: `Specific datasource instance`,
											Computed:            false,
											Optional:            true,
											Required:            false,
										},
									},
								},
							},
						},
					},
				},
			},
			"annotations": schema.SingleNestedAttribute{
				MarkdownDescription: `TODO docs`,
				Computed:            true,
				Optional:            true,
				Required:            false,
				Attributes: map[string]schema.Attribute{
					"list": schema.ListNestedAttribute{
						MarkdownDescription: ``,
						Computed:            false,
						Optional:            true,
						Required:            false,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: `Name of annotation.`,
									Computed:            false,
									Optional:            false,
									Required:            true,
								},
								"datasource": schema.SingleNestedAttribute{
									MarkdownDescription: `Datasource where the annotations data is`,
									Computed:            true,
									Optional:            true,
									Required:            false,
									Attributes: map[string]schema.Attribute{
										"type": schema.StringAttribute{
											MarkdownDescription: `The plugin type-id`,
											Computed:            false,
											Optional:            true,
											Required:            false,
										},
										"uid": schema.StringAttribute{
											MarkdownDescription: `Specific datasource instance`,
											Computed:            false,
											Optional:            true,
											Required:            false,
										},
									},
								},
								"enable": schema.BoolAttribute{
									MarkdownDescription: `When enabled the annotation query is issued with every dashboard refresh. Defaults to true.`,
									Computed:            true,
									Optional:            true,
									Required:            false,
								},
								"hide": schema.BoolAttribute{
									MarkdownDescription: `Annotation queries can be toggled on or off at the top of the dashboard.
When hide is true, the toggle is not shown in the dashboard. Defaults to false.`,
									Computed: true,
									Optional: true,
									Required: false,
								},
								"icon_color": schema.StringAttribute{
									MarkdownDescription: `Color to use for the annotation event markers`,
									Computed:            false,
									Optional:            false,
									Required:            true,
								},
								"filter": schema.SingleNestedAttribute{
									MarkdownDescription: `Filters to apply when fetching annotations`,
									Computed:            true,
									Optional:            true,
									Required:            false,
									Attributes: map[string]schema.Attribute{
										"exclude": schema.BoolAttribute{
											MarkdownDescription: `Should the specified panels be included or excluded. Defaults to false.`,
											Computed:            true,
											Optional:            true,
											Required:            false,
										},
										"ids": schema.ListAttribute{
											MarkdownDescription: `Panel IDs that should be included or excluded`,
											Computed:            false,
											Optional:            true,
											Required:            false,
											ElementType:         types.Int64Type,
										},
									},
								},
								"target": schema.SingleNestedAttribute{
									MarkdownDescription: `TODO.. this should just be a normal query target`,
									Computed:            true,
									Optional:            true,
									Required:            false,
									Attributes: map[string]schema.Attribute{
										"limit": schema.Int64Attribute{
											MarkdownDescription: `Only required/valid for the grafana datasource...
but code+tests is already depending on it so hard to change`,
											Computed: false,
											Optional: false,
											Required: true,
										},
										"match_any": schema.BoolAttribute{
											MarkdownDescription: `Only required/valid for the grafana datasource...
but code+tests is already depending on it so hard to change`,
											Computed: false,
											Optional: false,
											Required: true,
										},
										"tags": schema.ListAttribute{
											MarkdownDescription: `Only required/valid for the grafana datasource...
but code+tests is already depending on it so hard to change`,
											Computed:    false,
											Optional:    true,
											Required:    false,
											ElementType: types.StringType,
										},
										"type": schema.StringAttribute{
											MarkdownDescription: `Only required/valid for the grafana datasource...
but code+tests is already depending on it so hard to change`,
											Computed: false,
											Optional: false,
											Required: true,
										},
									},
								},
								"type": schema.StringAttribute{
									MarkdownDescription: `TODO -- this should not exist here, it is based on the --grafana-- datasource`,
									Computed:            false,
									Optional:            true,
									Required:            false,
								},
							},
						},
					},
				},
			},
			"links": schema.ListNestedAttribute{
				MarkdownDescription: `Links with references to other dashboards or external websites.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"title": schema.StringAttribute{
							MarkdownDescription: `Title to display with the link`,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"type": schema.StringAttribute{
							MarkdownDescription: `Link type. Accepted values are dashboards (to refer to another dashboard) and link (to refer to an external resource)`,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"icon": schema.StringAttribute{
							MarkdownDescription: `Icon name to be displayed with the link`,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"tooltip": schema.StringAttribute{
							MarkdownDescription: `Tooltip to display when the user hovers their mouse over it`,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"url": schema.StringAttribute{
							MarkdownDescription: `Link URL. Only required/valid if the type is link`,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"tags": schema.ListAttribute{
							MarkdownDescription: `List of tags to limit the linked dashboards. If empty, all dashboards will be displayed. Only valid if the type is dashboards`,
							Computed:            false,
							Optional:            true,
							Required:            false,
							ElementType:         types.StringType,
						},
						"as_dropdown": schema.BoolAttribute{
							MarkdownDescription: `If true, all dashboards links will be displayed in a dropdown. If false, all dashboards links will be displayed side by side. Only valid if the type is dashboards. Defaults to false.`,
							Computed:            true,
							Optional:            true,
							Required:            false,
						},
						"target_blank": schema.BoolAttribute{
							MarkdownDescription: `If true, the link will be opened in a new tab. Defaults to false.`,
							Computed:            true,
							Optional:            true,
							Required:            false,
						},
						"include_vars": schema.BoolAttribute{
							MarkdownDescription: `If true, includes current template variables values in the link as query params. Defaults to false.`,
							Computed:            true,
							Optional:            true,
							Required:            false,
						},
						"keep_time": schema.BoolAttribute{
							MarkdownDescription: `If true, includes current time range in the link as query params. Defaults to false.`,
							Computed:            true,
							Optional:            true,
							Required:            false,
						},
					},
				},
			},
			"snapshot": schema.SingleNestedAttribute{
				MarkdownDescription: ``,
				Computed:            true,
				Optional:            true,
				Required:            false,
				Attributes: map[string]schema.Attribute{
					"created": schema.StringAttribute{
						MarkdownDescription: `Time when the snapshot was created`,
						Computed:            false,
						Optional:            false,
						Required:            true,
					},
					"expires": schema.StringAttribute{
						MarkdownDescription: `Time when the snapshot expires, default is never to expire`,
						Computed:            false,
						Optional:            false,
						Required:            true,
					},
					"external": schema.BoolAttribute{
						MarkdownDescription: `Is the snapshot saved in an external grafana instance`,
						Computed:            false,
						Optional:            false,
						Required:            true,
					},
					"external_url": schema.StringAttribute{
						MarkdownDescription: `external url, if snapshot was shared in external grafana instance`,
						Computed:            false,
						Optional:            false,
						Required:            true,
					},
					"key": schema.StringAttribute{
						MarkdownDescription: `Optional, defined the unique key of the snapshot, required if external is true`,
						Computed:            false,
						Optional:            false,
						Required:            true,
					},
					"name": schema.StringAttribute{
						MarkdownDescription: `Optional, name of the snapshot`,
						Computed:            false,
						Optional:            false,
						Required:            true,
					},
					"org_id": schema.Int64Attribute{
						MarkdownDescription: `org id of the snapshot`,
						Computed:            false,
						Optional:            false,
						Required:            true,
					},
					"updated": schema.StringAttribute{
						MarkdownDescription: `last time when the snapshot was updated`,
						Computed:            false,
						Optional:            false,
						Required:            true,
					},
					"url": schema.StringAttribute{
						MarkdownDescription: `url of the snapshot, if snapshot was shared internally`,
						Computed:            false,
						Optional:            true,
						Required:            false,
					},
					"user_id": schema.Int64Attribute{
						MarkdownDescription: `user id of the snapshot creator`,
						Computed:            false,
						Optional:            false,
						Required:            true,
					},
				},
			},

			"rendered_json": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "This datasource rendered as JSON",
			},
		},
	}
}

func (d *CoreDashboardDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
}

func (d *CoreDashboardDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var data CoreDashboardDataSourceModel

	// Read Terraform configuration data into the model
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	JSONConfig, err := json.Marshal(data)
	if err != nil {
		resp.Diagnostics.AddError("JSON marshalling error", err.Error())
		return
	}

	// fix up the panel Attribute
	// Read into a map[string]interface{} and then marshal it back to JSON
	// This is a workaround for the fact that the panel attribute should be a list of maps but is a list of json strings
	dataMap := make(map[string]interface{})
	err = json.Unmarshal(JSONConfig, &dataMap)
	if err != nil {
		resp.Diagnostics.AddError("error unmarshalling config into Go map", err.Error())
		return
	}
	panels := data.Panels.Elements()
	panelsMaps := make([]map[string]interface{}, len(panels))
	for i, panel := range panels {
		panelMap := make(map[string]interface{})
		err = json.Unmarshal([]byte(panel.(types.String).ValueString()), &panelMap)
		if err != nil {
			resp.Diagnostics.AddError("error unmarshalling panel into go map", err.Error())
			return
		}
		panelsMaps[i] = panelMap
	}

	dataMap["panels"] = panelsMaps
	JSONConfig, err = json.MarshalIndent(dataMap, "", "  ")
	if err != nil {
		resp.Diagnostics.AddError("error marshalling go map into json", err.Error())
		return
	}

	// Not sure about that
	data.RenderedJSON = types.StringValue(string(JSONConfig))

	// Write logs using the tflog package
	// Documentation: https://terraform.io/plugin/log
	tflog.Trace(ctx, "read a data source")

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}
