// Code generated - EDITING IS FUTILE. DO NOT EDIT.
//
// Generated by pipeline:
//     terraform
// Using jennies:
//     TerraformDataSourceJenny
//     LatestJenny
//
// Run 'go generate ./' from repository root to regenerate.

package provider

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure that the imports are used to avoid compiler errors.
var _ attr.Value
var _ diag.Diagnostic

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ datasource.DataSource              = &CoreDashboardDataSource{}
	_ datasource.DataSourceWithConfigure = &CoreDashboardDataSource{}
)

func NewCoreDashboardDataSource() datasource.DataSource {
	return &CoreDashboardDataSource{}
}

// CoreDashboardDataSource defines the data source implementation.
type CoreDashboardDataSource struct{}

type CoreDashboardDataSourceModel_Time struct {
	From types.String `tfsdk:"from"`
	To   types.String `tfsdk:"to"`
}

func (m CoreDashboardDataSourceModel_Time) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Time struct {
		From string `json:"from"`
		To   string `json:"to"`
	}

	m = m.ApplyDefaults()
	attr_from := m.From.ValueString()
	attr_to := m.To.ValueString()

	model := &jsonCoreDashboardDataSourceModel_Time{
		From: attr_from,
		To:   attr_to,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Time) ApplyDefaults() CoreDashboardDataSourceModel_Time {
	if m.From.IsNull() {
		m.From = types.StringValue(`now-6h`)
	}
	if m.To.IsNull() {
		m.To = types.StringValue(`now`)
	}
	return m
}

type CoreDashboardDataSourceModel_Timepicker struct {
	Hidden           types.Bool `tfsdk:"hidden"`
	RefreshIntervals types.List `tfsdk:"refresh_intervals"`
	Collapse         types.Bool `tfsdk:"collapse"`
	Enable           types.Bool `tfsdk:"enable"`
	TimeOptions      types.List `tfsdk:"time_options"`
}

func (m CoreDashboardDataSourceModel_Timepicker) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Timepicker struct {
		Hidden           bool     `json:"hidden"`
		RefreshIntervals []string `json:"refresh_intervals,omitempty"`
		Collapse         bool     `json:"collapse"`
		Enable           bool     `json:"enable"`
		TimeOptions      []string `json:"time_options,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_hidden := m.Hidden.ValueBool()
	attr_refresh_intervals := []string{}
	for _, v := range m.RefreshIntervals.Elements() {
		attr_refresh_intervals = append(attr_refresh_intervals, v.(types.String).ValueString())
	}
	attr_collapse := m.Collapse.ValueBool()
	attr_enable := m.Enable.ValueBool()
	attr_time_options := []string{}
	for _, v := range m.TimeOptions.Elements() {
		attr_time_options = append(attr_time_options, v.(types.String).ValueString())
	}

	model := &jsonCoreDashboardDataSourceModel_Timepicker{
		Hidden:           attr_hidden,
		RefreshIntervals: attr_refresh_intervals,
		Collapse:         attr_collapse,
		Enable:           attr_enable,
		TimeOptions:      attr_time_options,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Timepicker) ApplyDefaults() CoreDashboardDataSourceModel_Timepicker {
	if m.Hidden.IsNull() {
		m.Hidden = types.BoolValue(false)
	}
	if len(m.RefreshIntervals.Elements()) == 0 {
		m.RefreshIntervals, _ = types.ListValue(types.StringType, []attr.Value{})
	}
	if m.Collapse.IsNull() {
		m.Collapse = types.BoolValue(false)
	}
	if m.Enable.IsNull() {
		m.Enable = types.BoolValue(true)
	}
	if len(m.TimeOptions.Elements()) == 0 {
		m.TimeOptions, _ = types.ListValue(types.StringType, []attr.Value{})
	}
	return m
}

type CoreDashboardDataSourceModel_Templating_List_Datasource struct {
	Type types.String `tfsdk:"type"`
	Uid  types.String `tfsdk:"uid"`
}

func (m CoreDashboardDataSourceModel_Templating_List_Datasource) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Templating_List_Datasource struct {
		Type *string `json:"type,omitempty"`
		Uid  *string `json:"uid,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_type := m.Type.ValueStringPointer()
	attr_uid := m.Uid.ValueStringPointer()

	model := &jsonCoreDashboardDataSourceModel_Templating_List_Datasource{
		Type: attr_type,
		Uid:  attr_uid,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Templating_List_Datasource) ApplyDefaults() CoreDashboardDataSourceModel_Templating_List_Datasource {

	return m
}

type CoreDashboardDataSourceModel_Templating_List_Current struct {
	Selected types.Bool   `tfsdk:"selected"`
	Text     types.String `tfsdk:"text"`
	Value    types.String `tfsdk:"value"`
}

func (m CoreDashboardDataSourceModel_Templating_List_Current) GetAttrText() interface{} {
	var attr interface{}
	var err error

	err = json.Unmarshal([]byte(m.Text.ValueString()), &attr)
	if err == nil {
		return attr
	}

	return m.Text.ValueString()
}

func (m CoreDashboardDataSourceModel_Templating_List_Current) GetAttrValue() interface{} {
	var attr interface{}
	var err error

	err = json.Unmarshal([]byte(m.Value.ValueString()), &attr)
	if err == nil {
		return attr
	}

	return m.Value.ValueString()
}

func (m CoreDashboardDataSourceModel_Templating_List_Current) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Templating_List_Current struct {
		Selected *bool       `json:"selected,omitempty"`
		Text     interface{} `json:"text"`
		Value    interface{} `json:"value"`
	}

	m = m.ApplyDefaults()
	attr_selected := m.Selected.ValueBoolPointer()
	attr_text := m.GetAttrText()
	attr_value := m.GetAttrValue()

	model := &jsonCoreDashboardDataSourceModel_Templating_List_Current{
		Selected: attr_selected,
		Text:     attr_text,
		Value:    attr_value,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Templating_List_Current) ApplyDefaults() CoreDashboardDataSourceModel_Templating_List_Current {

	return m
}

type CoreDashboardDataSourceModel_Templating_List_Options struct {
	Selected types.Bool   `tfsdk:"selected"`
	Text     types.String `tfsdk:"text"`
	Value    types.String `tfsdk:"value"`
}

func (m CoreDashboardDataSourceModel_Templating_List_Options) GetAttrText() interface{} {
	var attr interface{}
	var err error

	err = json.Unmarshal([]byte(m.Text.ValueString()), &attr)
	if err == nil {
		return attr
	}

	return m.Text.ValueString()
}

func (m CoreDashboardDataSourceModel_Templating_List_Options) GetAttrValue() interface{} {
	var attr interface{}
	var err error

	err = json.Unmarshal([]byte(m.Value.ValueString()), &attr)
	if err == nil {
		return attr
	}

	return m.Value.ValueString()
}

func (m CoreDashboardDataSourceModel_Templating_List_Options) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Templating_List_Options struct {
		Selected *bool       `json:"selected,omitempty"`
		Text     interface{} `json:"text"`
		Value    interface{} `json:"value"`
	}

	m = m.ApplyDefaults()
	attr_selected := m.Selected.ValueBoolPointer()
	attr_text := m.GetAttrText()
	attr_value := m.GetAttrValue()

	model := &jsonCoreDashboardDataSourceModel_Templating_List_Options{
		Selected: attr_selected,
		Text:     attr_text,
		Value:    attr_value,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Templating_List_Options) ApplyDefaults() CoreDashboardDataSourceModel_Templating_List_Options {

	return m
}

type CoreDashboardDataSourceModel_Templating_List struct {
	Type        types.String                                             `tfsdk:"type"`
	Name        types.String                                             `tfsdk:"name"`
	Label       types.String                                             `tfsdk:"label"`
	Hide        types.Int64                                              `tfsdk:"hide"`
	SkipUrlSync types.Bool                                               `tfsdk:"skip_url_sync"`
	Description types.String                                             `tfsdk:"description"`
	Query       types.String                                             `tfsdk:"query"`
	Datasource  *CoreDashboardDataSourceModel_Templating_List_Datasource `tfsdk:"datasource"`
	AllFormat   types.String                                             `tfsdk:"all_format"`
	Current     *CoreDashboardDataSourceModel_Templating_List_Current    `tfsdk:"current"`
	Multi       types.Bool                                               `tfsdk:"multi"`
	Options     []CoreDashboardDataSourceModel_Templating_List_Options   `tfsdk:"options"`
	Refresh     types.Int64                                              `tfsdk:"refresh"`
}

func (m CoreDashboardDataSourceModel_Templating_List) GetAttrQuery() interface{} {
	var attr interface{}
	var err error

	err = json.Unmarshal([]byte(m.Query.ValueString()), &attr)
	if err == nil {
		return attr
	}

	return m.Query.ValueString()
}

func (m CoreDashboardDataSourceModel_Templating_List) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Templating_List struct {
		Type        string        `json:"type"`
		Name        string        `json:"name"`
		Label       *string       `json:"label,omitempty"`
		Hide        int64         `json:"hide"`
		SkipUrlSync bool          `json:"skipUrlSync"`
		Description *string       `json:"description,omitempty"`
		Query       interface{}   `json:"query,omitempty"`
		Datasource  interface{}   `json:"datasource,omitempty"`
		AllFormat   *string       `json:"allFormat,omitempty"`
		Current     interface{}   `json:"current,omitempty"`
		Multi       *bool         `json:"multi,omitempty"`
		Options     []interface{} `json:"options,omitempty"`
		Refresh     *int64        `json:"refresh,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_type := m.Type.ValueString()
	attr_name := m.Name.ValueString()
	attr_label := m.Label.ValueStringPointer()
	attr_hide := m.Hide.ValueInt64()
	attr_skipurlsync := m.SkipUrlSync.ValueBool()
	attr_description := m.Description.ValueStringPointer()
	attr_query := m.GetAttrQuery()
	var attr_datasource interface{}
	if m.Datasource != nil {
		attr_datasource = m.Datasource
	}
	attr_allformat := m.AllFormat.ValueStringPointer()
	var attr_current interface{}
	if m.Current != nil {
		attr_current = m.Current
	}
	attr_multi := m.Multi.ValueBoolPointer()
	attr_options := []interface{}{}
	for _, v := range m.Options {
		attr_options = append(attr_options, v)
	}
	attr_refresh := m.Refresh.ValueInt64Pointer()

	model := &jsonCoreDashboardDataSourceModel_Templating_List{
		Type:        attr_type,
		Name:        attr_name,
		Label:       attr_label,
		Hide:        attr_hide,
		SkipUrlSync: attr_skipurlsync,
		Description: attr_description,
		Query:       attr_query,
		Datasource:  attr_datasource,
		AllFormat:   attr_allformat,
		Current:     attr_current,
		Multi:       attr_multi,
		Options:     attr_options,
		Refresh:     attr_refresh,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Templating_List) ApplyDefaults() CoreDashboardDataSourceModel_Templating_List {
	if m.SkipUrlSync.IsNull() {
		m.SkipUrlSync = types.BoolValue(false)
	}
	if m.Multi.IsNull() {
		m.Multi = types.BoolValue(false)
	}
	return m
}

type CoreDashboardDataSourceModel_Templating struct {
	List []CoreDashboardDataSourceModel_Templating_List `tfsdk:"list"`
}

func (m CoreDashboardDataSourceModel_Templating) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Templating struct {
		List []interface{} `json:"list,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_list := []interface{}{}
	for _, v := range m.List {
		attr_list = append(attr_list, v)
	}

	model := &jsonCoreDashboardDataSourceModel_Templating{
		List: attr_list,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Templating) ApplyDefaults() CoreDashboardDataSourceModel_Templating {

	return m
}

type CoreDashboardDataSourceModel_Annotations_List_Datasource struct {
	Type types.String `tfsdk:"type"`
	Uid  types.String `tfsdk:"uid"`
}

func (m CoreDashboardDataSourceModel_Annotations_List_Datasource) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Annotations_List_Datasource struct {
		Type *string `json:"type,omitempty"`
		Uid  *string `json:"uid,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_type := m.Type.ValueStringPointer()
	attr_uid := m.Uid.ValueStringPointer()

	model := &jsonCoreDashboardDataSourceModel_Annotations_List_Datasource{
		Type: attr_type,
		Uid:  attr_uid,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Annotations_List_Datasource) ApplyDefaults() CoreDashboardDataSourceModel_Annotations_List_Datasource {

	return m
}

type CoreDashboardDataSourceModel_Annotations_List_Filter struct {
	Exclude types.Bool `tfsdk:"exclude"`
	Ids     types.List `tfsdk:"ids"`
}

func (m CoreDashboardDataSourceModel_Annotations_List_Filter) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Annotations_List_Filter struct {
		Exclude *bool   `json:"exclude,omitempty"`
		Ids     []int64 `json:"ids,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_exclude := m.Exclude.ValueBoolPointer()
	attr_ids := []int64{}
	for _, v := range m.Ids.Elements() {
		attr_ids = append(attr_ids, v.(types.Int64).ValueInt64())
	}

	model := &jsonCoreDashboardDataSourceModel_Annotations_List_Filter{
		Exclude: attr_exclude,
		Ids:     attr_ids,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Annotations_List_Filter) ApplyDefaults() CoreDashboardDataSourceModel_Annotations_List_Filter {
	if m.Exclude.IsNull() {
		m.Exclude = types.BoolValue(false)
	}
	if len(m.Ids.Elements()) == 0 {
		m.Ids, _ = types.ListValue(types.Int64Type, []attr.Value{})
	}
	return m
}

type CoreDashboardDataSourceModel_Annotations_List_Target struct {
	Limit    types.Int64  `tfsdk:"limit"`
	MatchAny types.Bool   `tfsdk:"match_any"`
	Tags     types.List   `tfsdk:"tags"`
	Type     types.String `tfsdk:"type"`
}

func (m CoreDashboardDataSourceModel_Annotations_List_Target) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Annotations_List_Target struct {
		Limit    int64    `json:"limit"`
		MatchAny bool     `json:"matchAny"`
		Tags     []string `json:"tags,omitempty"`
		Type     string   `json:"type"`
	}

	m = m.ApplyDefaults()
	attr_limit := m.Limit.ValueInt64()
	attr_matchany := m.MatchAny.ValueBool()
	attr_tags := []string{}
	for _, v := range m.Tags.Elements() {
		attr_tags = append(attr_tags, v.(types.String).ValueString())
	}
	attr_type := m.Type.ValueString()

	model := &jsonCoreDashboardDataSourceModel_Annotations_List_Target{
		Limit:    attr_limit,
		MatchAny: attr_matchany,
		Tags:     attr_tags,
		Type:     attr_type,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Annotations_List_Target) ApplyDefaults() CoreDashboardDataSourceModel_Annotations_List_Target {
	if len(m.Tags.Elements()) == 0 {
		m.Tags, _ = types.ListValue(types.StringType, []attr.Value{})
	}
	return m
}

type CoreDashboardDataSourceModel_Annotations_List struct {
	Name       types.String                                              `tfsdk:"name"`
	Datasource *CoreDashboardDataSourceModel_Annotations_List_Datasource `tfsdk:"datasource"`
	Enable     types.Bool                                                `tfsdk:"enable"`
	Hide       types.Bool                                                `tfsdk:"hide"`
	IconColor  types.String                                              `tfsdk:"icon_color"`
	Filter     *CoreDashboardDataSourceModel_Annotations_List_Filter     `tfsdk:"filter"`
	Target     *CoreDashboardDataSourceModel_Annotations_List_Target     `tfsdk:"target"`
	Type       types.String                                              `tfsdk:"type"`
}

func (m CoreDashboardDataSourceModel_Annotations_List) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Annotations_List struct {
		Name       string      `json:"name"`
		Datasource interface{} `json:"datasource,omitempty"`
		Enable     bool        `json:"enable"`
		Hide       *bool       `json:"hide,omitempty"`
		IconColor  string      `json:"iconColor"`
		Filter     interface{} `json:"filter,omitempty"`
		Target     interface{} `json:"target,omitempty"`
		Type       *string     `json:"type,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_name := m.Name.ValueString()
	var attr_datasource interface{}
	if m.Datasource != nil {
		attr_datasource = m.Datasource
	}
	attr_enable := m.Enable.ValueBool()
	attr_hide := m.Hide.ValueBoolPointer()
	attr_iconcolor := m.IconColor.ValueString()
	var attr_filter interface{}
	if m.Filter != nil {
		attr_filter = m.Filter
	}
	var attr_target interface{}
	if m.Target != nil {
		attr_target = m.Target
	}
	attr_type := m.Type.ValueStringPointer()

	model := &jsonCoreDashboardDataSourceModel_Annotations_List{
		Name:       attr_name,
		Datasource: attr_datasource,
		Enable:     attr_enable,
		Hide:       attr_hide,
		IconColor:  attr_iconcolor,
		Filter:     attr_filter,
		Target:     attr_target,
		Type:       attr_type,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Annotations_List) ApplyDefaults() CoreDashboardDataSourceModel_Annotations_List {
	if m.Enable.IsNull() {
		m.Enable = types.BoolValue(true)
	}
	if m.Hide.IsNull() {
		m.Hide = types.BoolValue(false)
	}
	return m
}

type CoreDashboardDataSourceModel_Annotations struct {
	List []CoreDashboardDataSourceModel_Annotations_List `tfsdk:"list"`
}

func (m CoreDashboardDataSourceModel_Annotations) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Annotations struct {
		List []interface{} `json:"list,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_list := []interface{}{}
	for _, v := range m.List {
		attr_list = append(attr_list, v)
	}

	model := &jsonCoreDashboardDataSourceModel_Annotations{
		List: attr_list,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Annotations) ApplyDefaults() CoreDashboardDataSourceModel_Annotations {

	return m
}

type CoreDashboardDataSourceModel_Links struct {
	Title       types.String `tfsdk:"title"`
	Type        types.String `tfsdk:"type"`
	Icon        types.String `tfsdk:"icon"`
	Tooltip     types.String `tfsdk:"tooltip"`
	Url         types.String `tfsdk:"url"`
	Tags        types.List   `tfsdk:"tags"`
	AsDropdown  types.Bool   `tfsdk:"as_dropdown"`
	TargetBlank types.Bool   `tfsdk:"target_blank"`
	IncludeVars types.Bool   `tfsdk:"include_vars"`
	KeepTime    types.Bool   `tfsdk:"keep_time"`
}

func (m CoreDashboardDataSourceModel_Links) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Links struct {
		Title       string   `json:"title"`
		Type        string   `json:"type"`
		Icon        string   `json:"icon"`
		Tooltip     string   `json:"tooltip"`
		Url         string   `json:"url"`
		Tags        []string `json:"tags,omitempty"`
		AsDropdown  bool     `json:"asDropdown"`
		TargetBlank bool     `json:"targetBlank"`
		IncludeVars bool     `json:"includeVars"`
		KeepTime    bool     `json:"keepTime"`
	}

	m = m.ApplyDefaults()
	attr_title := m.Title.ValueString()
	attr_type := m.Type.ValueString()
	attr_icon := m.Icon.ValueString()
	attr_tooltip := m.Tooltip.ValueString()
	attr_url := m.Url.ValueString()
	attr_tags := []string{}
	for _, v := range m.Tags.Elements() {
		attr_tags = append(attr_tags, v.(types.String).ValueString())
	}
	attr_asdropdown := m.AsDropdown.ValueBool()
	attr_targetblank := m.TargetBlank.ValueBool()
	attr_includevars := m.IncludeVars.ValueBool()
	attr_keeptime := m.KeepTime.ValueBool()

	model := &jsonCoreDashboardDataSourceModel_Links{
		Title:       attr_title,
		Type:        attr_type,
		Icon:        attr_icon,
		Tooltip:     attr_tooltip,
		Url:         attr_url,
		Tags:        attr_tags,
		AsDropdown:  attr_asdropdown,
		TargetBlank: attr_targetblank,
		IncludeVars: attr_includevars,
		KeepTime:    attr_keeptime,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Links) ApplyDefaults() CoreDashboardDataSourceModel_Links {
	if len(m.Tags.Elements()) == 0 {
		m.Tags, _ = types.ListValue(types.StringType, []attr.Value{})
	}
	if m.AsDropdown.IsNull() {
		m.AsDropdown = types.BoolValue(false)
	}
	if m.TargetBlank.IsNull() {
		m.TargetBlank = types.BoolValue(false)
	}
	if m.IncludeVars.IsNull() {
		m.IncludeVars = types.BoolValue(false)
	}
	if m.KeepTime.IsNull() {
		m.KeepTime = types.BoolValue(false)
	}
	return m
}

type CoreDashboardDataSourceModel_Snapshot struct {
	Created     types.String `tfsdk:"created"`
	Expires     types.String `tfsdk:"expires"`
	External    types.Bool   `tfsdk:"external"`
	ExternalUrl types.String `tfsdk:"external_url"`
	Key         types.String `tfsdk:"key"`
	Name        types.String `tfsdk:"name"`
	OrgId       types.Int64  `tfsdk:"org_id"`
	Updated     types.String `tfsdk:"updated"`
	Url         types.String `tfsdk:"url"`
	UserId      types.Int64  `tfsdk:"user_id"`
}

func (m CoreDashboardDataSourceModel_Snapshot) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel_Snapshot struct {
		Created     string  `json:"created"`
		Expires     string  `json:"expires"`
		External    bool    `json:"external"`
		ExternalUrl string  `json:"externalUrl"`
		Key         string  `json:"key"`
		Name        string  `json:"name"`
		OrgId       int64   `json:"orgId"`
		Updated     string  `json:"updated"`
		Url         *string `json:"url,omitempty"`
		UserId      int64   `json:"userId"`
	}

	m = m.ApplyDefaults()
	attr_created := m.Created.ValueString()
	attr_expires := m.Expires.ValueString()
	attr_external := m.External.ValueBool()
	attr_externalurl := m.ExternalUrl.ValueString()
	attr_key := m.Key.ValueString()
	attr_name := m.Name.ValueString()
	attr_orgid := m.OrgId.ValueInt64()
	attr_updated := m.Updated.ValueString()
	attr_url := m.Url.ValueStringPointer()
	attr_userid := m.UserId.ValueInt64()

	model := &jsonCoreDashboardDataSourceModel_Snapshot{
		Created:     attr_created,
		Expires:     attr_expires,
		External:    attr_external,
		ExternalUrl: attr_externalurl,
		Key:         attr_key,
		Name:        attr_name,
		OrgId:       attr_orgid,
		Updated:     attr_updated,
		Url:         attr_url,
		UserId:      attr_userid,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel_Snapshot) ApplyDefaults() CoreDashboardDataSourceModel_Snapshot {

	return m
}

type CoreDashboardDataSourceModel struct {
	RenderedJSON         types.String                              `tfsdk:"rendered_json"`
	Uid                  types.String                              `tfsdk:"uid"`
	Title                types.String                              `tfsdk:"title"`
	Description          types.String                              `tfsdk:"description"`
	Revision             types.Int64                               `tfsdk:"revision"`
	GnetId               types.String                              `tfsdk:"gnet_id"`
	Tags                 types.List                                `tfsdk:"tags"`
	Style                types.String                              `tfsdk:"style"`
	Timezone             types.String                              `tfsdk:"timezone"`
	Editable             types.Bool                                `tfsdk:"editable"`
	GraphTooltip         types.Int64                               `tfsdk:"graph_tooltip"`
	Time                 *CoreDashboardDataSourceModel_Time        `tfsdk:"time"`
	Timepicker           *CoreDashboardDataSourceModel_Timepicker  `tfsdk:"timepicker"`
	FiscalYearStartMonth types.Int64                               `tfsdk:"fiscal_year_start_month"`
	LiveNow              types.Bool                                `tfsdk:"live_now"`
	WeekStart            types.String                              `tfsdk:"week_start"`
	Refresh              types.String                              `tfsdk:"refresh"`
	SchemaVersion        types.Int64                               `tfsdk:"schema_version"`
	Version              types.Int64                               `tfsdk:"version"`
	Panels               types.List                                `tfsdk:"panels"`
	Templating           *CoreDashboardDataSourceModel_Templating  `tfsdk:"templating"`
	Annotations          *CoreDashboardDataSourceModel_Annotations `tfsdk:"annotations"`
	Links                []CoreDashboardDataSourceModel_Links      `tfsdk:"links"`
	Snapshot             *CoreDashboardDataSourceModel_Snapshot    `tfsdk:"snapshot"`
}

func (m CoreDashboardDataSourceModel) GetAttrRefresh() interface{} {
	var attr interface{}
	var err error

	attr, err = strconv.ParseBool(m.Refresh.ValueString())
	if err == nil {
		return attr
	}

	return m.Refresh.ValueString()
}

func (m CoreDashboardDataSourceModel) MarshalJSON() ([]byte, error) {
	type jsonCoreDashboardDataSourceModel struct {
		Uid                  *string       `json:"uid,omitempty"`
		Title                *string       `json:"title,omitempty"`
		Description          *string       `json:"description,omitempty"`
		Revision             *int64        `json:"revision,omitempty"`
		GnetId               *string       `json:"gnetId,omitempty"`
		Tags                 []string      `json:"tags,omitempty"`
		Style                string        `json:"style"`
		Timezone             *string       `json:"timezone,omitempty"`
		Editable             bool          `json:"editable"`
		GraphTooltip         int64         `json:"graphTooltip"`
		Time                 interface{}   `json:"time,omitempty"`
		Timepicker           interface{}   `json:"timepicker,omitempty"`
		FiscalYearStartMonth *int64        `json:"fiscalYearStartMonth,omitempty"`
		LiveNow              *bool         `json:"liveNow,omitempty"`
		WeekStart            *string       `json:"weekStart,omitempty"`
		Refresh              interface{}   `json:"refresh,omitempty"`
		SchemaVersion        int64         `json:"schemaVersion"`
		Version              *int64        `json:"version,omitempty"`
		Panels               []string      `json:"panels,omitempty"`
		Templating           interface{}   `json:"templating,omitempty"`
		Annotations          interface{}   `json:"annotations,omitempty"`
		Links                []interface{} `json:"links,omitempty"`
		Snapshot             interface{}   `json:"snapshot,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_uid := m.Uid.ValueStringPointer()
	attr_title := m.Title.ValueStringPointer()
	attr_description := m.Description.ValueStringPointer()
	attr_revision := m.Revision.ValueInt64Pointer()
	attr_gnetid := m.GnetId.ValueStringPointer()
	attr_tags := []string{}
	for _, v := range m.Tags.Elements() {
		attr_tags = append(attr_tags, v.(types.String).ValueString())
	}
	attr_style := m.Style.ValueString()
	attr_timezone := m.Timezone.ValueStringPointer()
	attr_editable := m.Editable.ValueBool()
	attr_graphtooltip := m.GraphTooltip.ValueInt64()
	var attr_time interface{}
	if m.Time != nil {
		attr_time = m.Time
	}
	var attr_timepicker interface{}
	if m.Timepicker != nil {
		attr_timepicker = m.Timepicker
	}
	attr_fiscalyearstartmonth := m.FiscalYearStartMonth.ValueInt64Pointer()
	attr_livenow := m.LiveNow.ValueBoolPointer()
	attr_weekstart := m.WeekStart.ValueStringPointer()
	attr_refresh := m.GetAttrRefresh()
	attr_schemaversion := m.SchemaVersion.ValueInt64()
	attr_version := m.Version.ValueInt64Pointer()
	attr_panels := []string{}
	for _, v := range m.Panels.Elements() {
		attr_panels = append(attr_panels, v.(types.String).ValueString())
	}
	var attr_templating interface{}
	if m.Templating != nil {
		attr_templating = m.Templating
	}
	var attr_annotations interface{}
	if m.Annotations != nil {
		attr_annotations = m.Annotations
	}
	attr_links := []interface{}{}
	for _, v := range m.Links {
		attr_links = append(attr_links, v)
	}
	var attr_snapshot interface{}
	if m.Snapshot != nil {
		attr_snapshot = m.Snapshot
	}

	model := &jsonCoreDashboardDataSourceModel{
		Uid:                  attr_uid,
		Title:                attr_title,
		Description:          attr_description,
		Revision:             attr_revision,
		GnetId:               attr_gnetid,
		Tags:                 attr_tags,
		Style:                attr_style,
		Timezone:             attr_timezone,
		Editable:             attr_editable,
		GraphTooltip:         attr_graphtooltip,
		Time:                 attr_time,
		Timepicker:           attr_timepicker,
		FiscalYearStartMonth: attr_fiscalyearstartmonth,
		LiveNow:              attr_livenow,
		WeekStart:            attr_weekstart,
		Refresh:              attr_refresh,
		SchemaVersion:        attr_schemaversion,
		Version:              attr_version,
		Panels:               attr_panels,
		Templating:           attr_templating,
		Annotations:          attr_annotations,
		Links:                attr_links,
		Snapshot:             attr_snapshot,
	}
	return json.Marshal(model)
}

func (m CoreDashboardDataSourceModel) ApplyDefaults() CoreDashboardDataSourceModel {
	if len(m.Tags.Elements()) == 0 {
		m.Tags, _ = types.ListValue(types.StringType, []attr.Value{})
	}
	if m.Style.IsNull() {
		m.Style = types.StringValue(`dark`)
	}
	if m.Timezone.IsNull() {
		m.Timezone = types.StringValue(`browser`)
	}
	if m.Editable.IsNull() {
		m.Editable = types.BoolValue(true)
	}
	if m.GraphTooltip.IsNull() {
		m.GraphTooltip = types.Int64Value(0)
	}
	if m.FiscalYearStartMonth.IsNull() {
		m.FiscalYearStartMonth = types.Int64Value(0)
	}
	if m.SchemaVersion.IsNull() {
		m.SchemaVersion = types.Int64Value(36)
	}
	if len(m.Panels.Elements()) == 0 {
		m.Panels, _ = types.ListValue(types.StringType, []attr.Value{})
	}
	return m
}

func (d *CoreDashboardDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_core_dashboard"
}

func (d *CoreDashboardDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"uid": schema.StringAttribute{
				MarkdownDescription: `Unique dashboard identifier that can be generated by anyone. string (8-40)`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"title": schema.StringAttribute{
				MarkdownDescription: `Title of dashboard.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: `Description of dashboard.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"revision": schema.Int64Attribute{
				MarkdownDescription: `This property should only be used in dashboards defined by plugins.  It is a quick check
to see if the version has changed since the last time.`,
				Computed: false,
				Optional: true,
				Required: false,
			},
			"gnet_id": schema.StringAttribute{
				MarkdownDescription: `ID of a dashboard imported from the https://grafana.com/grafana/dashboards/ portal`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"tags": schema.ListAttribute{
				MarkdownDescription: `Tags associated with dashboard.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
				ElementType:         types.StringType,
			},
			"style": schema.StringAttribute{
				MarkdownDescription: `Theme of dashboard.
Default value: dark. Defaults to "dark".`,
				Computed: true,
				Optional: true,
				Required: false,
			},
			"timezone": schema.StringAttribute{
				MarkdownDescription: `Timezone of dashboard. Accepted values are IANA TZDB zone ID or "browser" or "utc". Defaults to "browser".`,
				Computed:            true,
				Optional:            true,
				Required:            false,
			},
			"editable": schema.BoolAttribute{
				MarkdownDescription: `Whether a dashboard is editable or not. Defaults to true.`,
				Computed:            true,
				Optional:            true,
				Required:            false,
			},
			"graph_tooltip": schema.Int64Attribute{
				MarkdownDescription: `Configuration of dashboard cursor sync behavior.
Accepted values are 0 (sync turned off), 1 (shared crosshair), 2 (shared crosshair and tooltip). Defaults to 0.`,
				Computed: true,
				Optional: true,
				Required: false,
			},
			"time": schema.SingleNestedAttribute{
				MarkdownDescription: `Time range for dashboard.
Accepted values are relative time strings like {from: 'now-6h', to: 'now'} or absolute time strings like {from: '2020-07-10T08:00:00.000Z', to: '2020-07-10T14:00:00.000Z'}.`,
				Computed: true,
				Optional: true,
				Required: false,
				Attributes: map[string]schema.Attribute{
					"from": schema.StringAttribute{
						MarkdownDescription: ` Defaults to "now-6h".`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"to": schema.StringAttribute{
						MarkdownDescription: ` Defaults to "now".`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
				},
			},
			"timepicker": schema.SingleNestedAttribute{
				MarkdownDescription: `Configuration of the time picker shown at the top of a dashboard.`,
				Computed:            true,
				Optional:            true,
				Required:            false,
				Attributes: map[string]schema.Attribute{
					"hidden": schema.BoolAttribute{
						MarkdownDescription: `Whether timepicker is visible or not. Defaults to false.`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"refresh_intervals": schema.ListAttribute{
						MarkdownDescription: `Interval options available in the refresh picker dropdown.`,
						Computed:            false,
						Optional:            true,
						Required:            false,
						ElementType:         types.StringType,
					},
					"collapse": schema.BoolAttribute{
						MarkdownDescription: `Whether timepicker is collapsed or not. Has no effect on provisioned dashboard. Defaults to false.`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"enable": schema.BoolAttribute{
						MarkdownDescription: `Whether timepicker is enabled or not. Has no effect on provisioned dashboard. Defaults to true.`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"time_options": schema.ListAttribute{
						MarkdownDescription: `Selectable options available in the time picker dropdown. Has no effect on provisioned dashboard.`,
						Computed:            false,
						Optional:            true,
						Required:            false,
						ElementType:         types.StringType,
					},
				},
			},
			"fiscal_year_start_month": schema.Int64Attribute{
				MarkdownDescription: `The month that the fiscal year starts on.  0 = January, 11 = December. Defaults to 0.`,
				Computed:            true,
				Optional:            true,
				Required:            false,
			},
			"live_now": schema.BoolAttribute{
				MarkdownDescription: `When set to true, the dashboard will redraw panels at an interval matching the pixel width.
This will keep data "moving left" regardless of the query refresh rate. This setting helps
avoid dashboards presenting stale live data`,
				Computed: false,
				Optional: true,
				Required: false,
			},
			"week_start": schema.StringAttribute{
				MarkdownDescription: `Day when the week starts. Expressed by the name of the day in lowercase, e.g. "monday".`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"refresh": schema.StringAttribute{
				MarkdownDescription: `Refresh rate of dashboard. Represented via interval string, e.g. "5s", "1m", "1h", "1d".`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"schema_version": schema.Int64Attribute{
				MarkdownDescription: `Version of the JSON schema, incremented each time a Grafana update brings
changes to said schema. Defaults to 36.`,
				Computed: true,
				Optional: true,
				Required: false,
			},
			"version": schema.Int64Attribute{
				MarkdownDescription: `Version of the dashboard, incremented each time the dashboard is updated.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"panels": schema.ListAttribute{
				MarkdownDescription: `List of dashboard panels`,
				Computed:            false,
				Optional:            true,
				Required:            false,
				ElementType:         types.StringType,
			},
			"templating": schema.SingleNestedAttribute{
				MarkdownDescription: `Configured template variables`,
				Computed:            true,
				Optional:            true,
				Required:            false,
				Attributes: map[string]schema.Attribute{
					"list": schema.ListNestedAttribute{
						MarkdownDescription: `List of configured template variables with their saved values along with some other metadata`,
						Computed:            false,
						Optional:            true,
						Required:            false,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"type": schema.StringAttribute{
									MarkdownDescription: `Type of variable`,
									Computed:            false,
									Optional:            false,
									Required:            true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: `Name of variable`,
									Computed:            false,
									Optional:            false,
									Required:            true,
								},
								"label": schema.StringAttribute{
									MarkdownDescription: `Optional display name`,
									Computed:            false,
									Optional:            true,
									Required:            false,
								},
								"hide": schema.Int64Attribute{
									MarkdownDescription: `Visibility configuration for the variable`,
									Computed:            false,
									Optional:            false,
									Required:            true,
								},
								"skip_url_sync": schema.BoolAttribute{
									MarkdownDescription: `Whether the variable value should be managed by URL query params or not. Defaults to false.`,
									Computed:            true,
									Optional:            true,
									Required:            false,
								},
								"description": schema.StringAttribute{
									MarkdownDescription: `Description of variable. It can be defined but null.`,
									Computed:            false,
									Optional:            true,
									Required:            false,
								},
								"query": schema.StringAttribute{
									MarkdownDescription: `JSON-encoded string. Query used to fetch values for a variable`,
									Computed:            false,
									Optional:            true,
									Required:            false,
								},
								"datasource": schema.SingleNestedAttribute{
									MarkdownDescription: `Data source used to fetch values for a variable. It can be defined but null.`,
									Computed:            true,
									Optional:            true,
									Required:            false,
									Attributes: map[string]schema.Attribute{
										"type": schema.StringAttribute{
											MarkdownDescription: `The plugin type-id`,
											Computed:            false,
											Optional:            true,
											Required:            false,
										},
										"uid": schema.StringAttribute{
											MarkdownDescription: `Specific datasource instance`,
											Computed:            false,
											Optional:            true,
											Required:            false,
										},
									},
								},
								"all_format": schema.StringAttribute{
									MarkdownDescription: `Format to use while fetching all values from data source, eg: wildcard, glob, regex, pipe, etc.`,
									Computed:            false,
									Optional:            true,
									Required:            false,
								},
								"current": schema.SingleNestedAttribute{
									MarkdownDescription: `Shows current selected variable text/value on the dashboard`,
									Computed:            true,
									Optional:            true,
									Required:            false,
									Attributes: map[string]schema.Attribute{
										"selected": schema.BoolAttribute{
											MarkdownDescription: `Whether the option is selected or not`,
											Computed:            false,
											Optional:            true,
											Required:            false,
										},
										"text": schema.StringAttribute{
											MarkdownDescription: `JSON-encoded string. Text to be displayed for the option`,
											Computed:            false,
											Optional:            false,
											Required:            true,
										},
										"value": schema.StringAttribute{
											MarkdownDescription: `JSON-encoded string. Value of the option`,
											Computed:            false,
											Optional:            false,
											Required:            true,
										},
									},
								},
								"multi": schema.BoolAttribute{
									MarkdownDescription: `Whether multiple values can be selected or not from variable value list. Defaults to false.`,
									Computed:            true,
									Optional:            true,
									Required:            false,
								},
								"options": schema.ListNestedAttribute{
									MarkdownDescription: `Options that can be selected for a variable.`,
									Computed:            false,
									Optional:            true,
									Required:            false,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"selected": schema.BoolAttribute{
												MarkdownDescription: `Whether the option is selected or not`,
												Computed:            false,
												Optional:            true,
												Required:            false,
											},
											"text": schema.StringAttribute{
												MarkdownDescription: `JSON-encoded string. Text to be displayed for the option`,
												Computed:            false,
												Optional:            false,
												Required:            true,
											},
											"value": schema.StringAttribute{
												MarkdownDescription: `JSON-encoded string. Value of the option`,
												Computed:            false,
												Optional:            false,
												Required:            true,
											},
										},
									},
								},
								"refresh": schema.Int64Attribute{
									MarkdownDescription: ``,
									Computed:            false,
									Optional:            true,
									Required:            false,
								},
							},
						},
					},
				},
			},
			"annotations": schema.SingleNestedAttribute{
				MarkdownDescription: `Contains the list of annotations that are associated with the dashboard.
Annotations are used to overlay event markers and overlay event tags on graphs.
Grafana comes with a native annotation store and the ability to add annotation events directly from the graph panel or via the HTTP API.
See https://grafana.com/docs/grafana/latest/dashboards/build-dashboards/annotate-visualizations/`,
				Computed: true,
				Optional: true,
				Required: false,
				Attributes: map[string]schema.Attribute{
					"list": schema.ListNestedAttribute{
						MarkdownDescription: `List of annotations`,
						Computed:            false,
						Optional:            true,
						Required:            false,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: `Name of annotation.`,
									Computed:            false,
									Optional:            false,
									Required:            true,
								},
								"datasource": schema.SingleNestedAttribute{
									MarkdownDescription: `Datasource where the annotations data is`,
									Computed:            true,
									Optional:            true,
									Required:            false,
									Attributes: map[string]schema.Attribute{
										"type": schema.StringAttribute{
											MarkdownDescription: `The plugin type-id`,
											Computed:            false,
											Optional:            true,
											Required:            false,
										},
										"uid": schema.StringAttribute{
											MarkdownDescription: `Specific datasource instance`,
											Computed:            false,
											Optional:            true,
											Required:            false,
										},
									},
								},
								"enable": schema.BoolAttribute{
									MarkdownDescription: `When enabled the annotation query is issued with every dashboard refresh. Defaults to true.`,
									Computed:            true,
									Optional:            true,
									Required:            false,
								},
								"hide": schema.BoolAttribute{
									MarkdownDescription: `Annotation queries can be toggled on or off at the top of the dashboard.
When hide is true, the toggle is not shown in the dashboard. Defaults to false.`,
									Computed: true,
									Optional: true,
									Required: false,
								},
								"icon_color": schema.StringAttribute{
									MarkdownDescription: `Color to use for the annotation event markers`,
									Computed:            false,
									Optional:            false,
									Required:            true,
								},
								"filter": schema.SingleNestedAttribute{
									MarkdownDescription: `Filters to apply when fetching annotations`,
									Computed:            true,
									Optional:            true,
									Required:            false,
									Attributes: map[string]schema.Attribute{
										"exclude": schema.BoolAttribute{
											MarkdownDescription: `Should the specified panels be included or excluded. Defaults to false.`,
											Computed:            true,
											Optional:            true,
											Required:            false,
										},
										"ids": schema.ListAttribute{
											MarkdownDescription: `Panel IDs that should be included or excluded`,
											Computed:            false,
											Optional:            true,
											Required:            false,
											ElementType:         types.Int64Type,
										},
									},
								},
								"target": schema.SingleNestedAttribute{
									MarkdownDescription: `TODO.. this should just be a normal query target`,
									Computed:            true,
									Optional:            true,
									Required:            false,
									Attributes: map[string]schema.Attribute{
										"limit": schema.Int64Attribute{
											MarkdownDescription: `Only required/valid for the grafana datasource...
but code+tests is already depending on it so hard to change`,
											Computed: false,
											Optional: false,
											Required: true,
										},
										"match_any": schema.BoolAttribute{
											MarkdownDescription: `Only required/valid for the grafana datasource...
but code+tests is already depending on it so hard to change`,
											Computed: false,
											Optional: false,
											Required: true,
										},
										"tags": schema.ListAttribute{
											MarkdownDescription: `Only required/valid for the grafana datasource...
but code+tests is already depending on it so hard to change`,
											Computed:    false,
											Optional:    true,
											Required:    false,
											ElementType: types.StringType,
										},
										"type": schema.StringAttribute{
											MarkdownDescription: `Only required/valid for the grafana datasource...
but code+tests is already depending on it so hard to change`,
											Computed: false,
											Optional: false,
											Required: true,
										},
									},
								},
								"type": schema.StringAttribute{
									MarkdownDescription: `TODO -- this should not exist here, it is based on the --grafana-- datasource`,
									Computed:            false,
									Optional:            true,
									Required:            false,
								},
							},
						},
					},
				},
			},
			"links": schema.ListNestedAttribute{
				MarkdownDescription: `Links with references to other dashboards or external websites.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"title": schema.StringAttribute{
							MarkdownDescription: `Title to display with the link`,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"type": schema.StringAttribute{
							MarkdownDescription: `Link type. Accepted values are dashboards (to refer to another dashboard) and link (to refer to an external resource)`,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"icon": schema.StringAttribute{
							MarkdownDescription: `Icon name to be displayed with the link`,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"tooltip": schema.StringAttribute{
							MarkdownDescription: `Tooltip to display when the user hovers their mouse over it`,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"url": schema.StringAttribute{
							MarkdownDescription: `Link URL. Only required/valid if the type is link`,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"tags": schema.ListAttribute{
							MarkdownDescription: `List of tags to limit the linked dashboards. If empty, all dashboards will be displayed. Only valid if the type is dashboards`,
							Computed:            false,
							Optional:            true,
							Required:            false,
							ElementType:         types.StringType,
						},
						"as_dropdown": schema.BoolAttribute{
							MarkdownDescription: `If true, all dashboards links will be displayed in a dropdown. If false, all dashboards links will be displayed side by side. Only valid if the type is dashboards. Defaults to false.`,
							Computed:            true,
							Optional:            true,
							Required:            false,
						},
						"target_blank": schema.BoolAttribute{
							MarkdownDescription: `If true, the link will be opened in a new tab. Defaults to false.`,
							Computed:            true,
							Optional:            true,
							Required:            false,
						},
						"include_vars": schema.BoolAttribute{
							MarkdownDescription: `If true, includes current template variables values in the link as query params. Defaults to false.`,
							Computed:            true,
							Optional:            true,
							Required:            false,
						},
						"keep_time": schema.BoolAttribute{
							MarkdownDescription: `If true, includes current time range in the link as query params. Defaults to false.`,
							Computed:            true,
							Optional:            true,
							Required:            false,
						},
					},
				},
			},
			"snapshot": schema.SingleNestedAttribute{
				MarkdownDescription: `Snapshot options. They are present only if the dashboard is a snapshot.`,
				Computed:            true,
				Optional:            true,
				Required:            false,
				Attributes: map[string]schema.Attribute{
					"created": schema.StringAttribute{
						MarkdownDescription: `Time when the snapshot was created`,
						Computed:            false,
						Optional:            false,
						Required:            true,
					},
					"expires": schema.StringAttribute{
						MarkdownDescription: `Time when the snapshot expires, default is never to expire`,
						Computed:            false,
						Optional:            false,
						Required:            true,
					},
					"external": schema.BoolAttribute{
						MarkdownDescription: `Is the snapshot saved in an external grafana instance`,
						Computed:            false,
						Optional:            false,
						Required:            true,
					},
					"external_url": schema.StringAttribute{
						MarkdownDescription: `external url, if snapshot was shared in external grafana instance`,
						Computed:            false,
						Optional:            false,
						Required:            true,
					},
					"key": schema.StringAttribute{
						MarkdownDescription: `Optional, defined the unique key of the snapshot, required if external is true`,
						Computed:            false,
						Optional:            false,
						Required:            true,
					},
					"name": schema.StringAttribute{
						MarkdownDescription: `Optional, name of the snapshot`,
						Computed:            false,
						Optional:            false,
						Required:            true,
					},
					"org_id": schema.Int64Attribute{
						MarkdownDescription: `org id of the snapshot`,
						Computed:            false,
						Optional:            false,
						Required:            true,
					},
					"updated": schema.StringAttribute{
						MarkdownDescription: `last time when the snapshot was updated`,
						Computed:            false,
						Optional:            false,
						Required:            true,
					},
					"url": schema.StringAttribute{
						MarkdownDescription: `url of the snapshot, if snapshot was shared internally`,
						Computed:            false,
						Optional:            true,
						Required:            false,
					},
					"user_id": schema.Int64Attribute{
						MarkdownDescription: `user id of the snapshot creator`,
						Computed:            false,
						Optional:            false,
						Required:            true,
					},
				},
			},

			"rendered_json": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "This datasource rendered as JSON",
			},
		},
	}
}

func (d *CoreDashboardDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
}

func (d *CoreDashboardDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var data CoreDashboardDataSourceModel

	// Read Terraform configuration data into the model
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	JSONConfig, err := json.Marshal(data)
	if err != nil {
		resp.Diagnostics.AddError("JSON marshalling error", err.Error())
		return
	}

	// fix up the panel Attribute
	// Read into a map[string]interface{} and then marshal it back to JSON
	// This is a workaround for the fact that the panel attribute should be a list of maps but is a list of json strings
	dataMap := make(map[string]interface{})
	err = json.Unmarshal(JSONConfig, &dataMap)
	if err != nil {
		resp.Diagnostics.AddError("error unmarshalling config into Go map", err.Error())
		return
	}
	panels := data.Panels.Elements()
	panelsMaps := make([]map[string]interface{}, len(panels))
	for i, panel := range panels {
		panelMap := make(map[string]interface{})
		err = json.Unmarshal([]byte(panel.(types.String).ValueString()), &panelMap)
		if err != nil {
			resp.Diagnostics.AddError("error unmarshalling panel into go map", err.Error())
			return
		}
		panelsMaps[i] = panelMap
	}

	dataMap["panels"] = panelsMaps
	JSONConfig, err = json.MarshalIndent(dataMap, "", "  ")
	if err != nil {
		resp.Diagnostics.AddError("error marshalling go map into json", err.Error())
		return
	}

	// Not sure about that
	data.RenderedJSON = types.StringValue(string(JSONConfig))

	// Write logs using the tflog package
	// Documentation: https://terraform.io/plugin/log
	tflog.Trace(ctx, "read a data source")

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}
