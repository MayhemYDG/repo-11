// Code generated - EDITING IS FUTILE. DO NOT EDIT.
//
// Generated by pipeline:
//     terraform
// Using jennies:
//     TerraformDataSourceJenny
//     ComposableLatestMajorsOrXJenny
//
// Run 'go generate ./' from repository root to regenerate.

package provider

import (
	"context"
	"encoding/json"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure that the imports are used to avoid compiler errors.
var _ attr.Value
var _ diag.Diagnostic

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ datasource.DataSource              = &PanelHeatmapDataSource{}
	_ datasource.DataSourceWithConfigure = &PanelHeatmapDataSource{}
)

func NewPanelHeatmapDataSource() datasource.DataSource {
	return &PanelHeatmapDataSource{}
}

// PanelHeatmapDataSource defines the data source implementation.
type PanelHeatmapDataSource struct{}

type PanelHeatmapDataSourceModel_Datasource struct {
	Type types.String `tfsdk:"type"`
	Uid  types.String `tfsdk:"uid"`
}

func (m PanelHeatmapDataSourceModel_Datasource) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_Datasource struct {
		Type *string `json:"type,omitempty"`
		Uid  *string `json:"uid,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_type := m.Type.ValueString()
	attr_uid := m.Uid.ValueString()

	model := &jsonPanelHeatmapDataSourceModel_Datasource{
		Type: &attr_type,
		Uid:  &attr_uid,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_Datasource) ApplyDefaults() PanelHeatmapDataSourceModel_Datasource {

	return m
}

type PanelHeatmapDataSourceModel_GridPos struct {
	H      types.Int64 `tfsdk:"h"`
	W      types.Int64 `tfsdk:"w"`
	X      types.Int64 `tfsdk:"x"`
	Y      types.Int64 `tfsdk:"y"`
	Static types.Bool  `tfsdk:"static"`
}

func (m PanelHeatmapDataSourceModel_GridPos) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_GridPos struct {
		H      int64 `json:"h"`
		W      int64 `json:"w"`
		X      int64 `json:"x"`
		Y      int64 `json:"y"`
		Static *bool `json:"static,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_h := m.H.ValueInt64()
	attr_w := m.W.ValueInt64()
	attr_x := m.X.ValueInt64()
	attr_y := m.Y.ValueInt64()
	attr_static := m.Static.ValueBool()

	model := &jsonPanelHeatmapDataSourceModel_GridPos{
		H:      attr_h,
		W:      attr_w,
		X:      attr_x,
		Y:      attr_y,
		Static: &attr_static,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_GridPos) ApplyDefaults() PanelHeatmapDataSourceModel_GridPos {
	if m.H.IsNull() {
		m.H = types.Int64Value(9)
	}
	if m.W.IsNull() {
		m.W = types.Int64Value(12)
	}
	if m.X.IsNull() {
		m.X = types.Int64Value(0)
	}
	if m.Y.IsNull() {
		m.Y = types.Int64Value(0)
	}
	return m
}

type PanelHeatmapDataSourceModel_Links struct {
	Title       types.String `tfsdk:"title"`
	Type        types.String `tfsdk:"type"`
	Icon        types.String `tfsdk:"icon"`
	Tooltip     types.String `tfsdk:"tooltip"`
	Url         types.String `tfsdk:"url"`
	Tags        types.List   `tfsdk:"tags"`
	AsDropdown  types.Bool   `tfsdk:"as_dropdown"`
	TargetBlank types.Bool   `tfsdk:"target_blank"`
	IncludeVars types.Bool   `tfsdk:"include_vars"`
	KeepTime    types.Bool   `tfsdk:"keep_time"`
}

func (m PanelHeatmapDataSourceModel_Links) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_Links struct {
		Title       string   `json:"title"`
		Type        string   `json:"type"`
		Icon        string   `json:"icon"`
		Tooltip     string   `json:"tooltip"`
		Url         string   `json:"url"`
		Tags        []string `json:"tags,omitempty"`
		AsDropdown  bool     `json:"asDropdown"`
		TargetBlank bool     `json:"targetBlank"`
		IncludeVars bool     `json:"includeVars"`
		KeepTime    bool     `json:"keepTime"`
	}

	m = m.ApplyDefaults()
	attr_title := m.Title.ValueString()
	attr_type := m.Type.ValueString()
	attr_icon := m.Icon.ValueString()
	attr_tooltip := m.Tooltip.ValueString()
	attr_url := m.Url.ValueString()
	attr_tags := []string{}
	for _, v := range m.Tags.Elements() {
		attr_tags = append(attr_tags, v.(types.String).ValueString())
	}
	attr_asdropdown := m.AsDropdown.ValueBool()
	attr_targetblank := m.TargetBlank.ValueBool()
	attr_includevars := m.IncludeVars.ValueBool()
	attr_keeptime := m.KeepTime.ValueBool()

	model := &jsonPanelHeatmapDataSourceModel_Links{
		Title:       attr_title,
		Type:        attr_type,
		Icon:        attr_icon,
		Tooltip:     attr_tooltip,
		Url:         attr_url,
		Tags:        attr_tags,
		AsDropdown:  attr_asdropdown,
		TargetBlank: attr_targetblank,
		IncludeVars: attr_includevars,
		KeepTime:    attr_keeptime,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_Links) ApplyDefaults() PanelHeatmapDataSourceModel_Links {
	if len(m.Tags.Elements()) == 0 {
		m.Tags, _ = types.ListValue(types.StringType, []attr.Value{})
	}
	if m.AsDropdown.IsNull() {
		m.AsDropdown = types.BoolValue(false)
	}
	if m.TargetBlank.IsNull() {
		m.TargetBlank = types.BoolValue(false)
	}
	if m.IncludeVars.IsNull() {
		m.IncludeVars = types.BoolValue(false)
	}
	if m.KeepTime.IsNull() {
		m.KeepTime = types.BoolValue(false)
	}
	return m
}

type PanelHeatmapDataSourceModel_Transformations_Filter struct {
}

func (m PanelHeatmapDataSourceModel_Transformations_Filter) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_Transformations_Filter struct {
	}

	m = m.ApplyDefaults()

	model := &jsonPanelHeatmapDataSourceModel_Transformations_Filter{}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_Transformations_Filter) ApplyDefaults() PanelHeatmapDataSourceModel_Transformations_Filter {

	return m
}

type PanelHeatmapDataSourceModel_Transformations struct {
	Disabled types.Bool                                          `tfsdk:"disabled"`
	Filter   *PanelHeatmapDataSourceModel_Transformations_Filter `tfsdk:"filter"`
}

func (m PanelHeatmapDataSourceModel_Transformations) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_Transformations struct {
		Disabled *bool       `json:"disabled,omitempty"`
		Filter   interface{} `json:"filter,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_disabled := m.Disabled.ValueBool()
	var attr_filter interface{}
	if m.Filter != nil {
		attr_filter = m.Filter
	}

	model := &jsonPanelHeatmapDataSourceModel_Transformations{
		Disabled: &attr_disabled,
		Filter:   attr_filter,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_Transformations) ApplyDefaults() PanelHeatmapDataSourceModel_Transformations {

	return m
}

type PanelHeatmapDataSourceModel_LibraryPanel struct {
	Name types.String `tfsdk:"name"`
	Uid  types.String `tfsdk:"uid"`
}

func (m PanelHeatmapDataSourceModel_LibraryPanel) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_LibraryPanel struct {
		Name string `json:"name"`
		Uid  string `json:"uid"`
	}

	m = m.ApplyDefaults()
	attr_name := m.Name.ValueString()
	attr_uid := m.Uid.ValueString()

	model := &jsonPanelHeatmapDataSourceModel_LibraryPanel{
		Name: attr_name,
		Uid:  attr_uid,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_LibraryPanel) ApplyDefaults() PanelHeatmapDataSourceModel_LibraryPanel {

	return m
}

type PanelHeatmapDataSourceModel_Options_Calculation_XBuckets_Scale struct {
	Type            types.String  `tfsdk:"type"`
	Log             types.Float64 `tfsdk:"log"`
	LinearThreshold types.Float64 `tfsdk:"linear_threshold"`
}

func (m PanelHeatmapDataSourceModel_Options_Calculation_XBuckets_Scale) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_Options_Calculation_XBuckets_Scale struct {
		Type            string   `json:"type"`
		Log             *float64 `json:"log,omitempty"`
		LinearThreshold *float64 `json:"linearThreshold,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_type := m.Type.ValueString()
	attr_log := m.Log.ValueFloat64()
	attr_linearthreshold := m.LinearThreshold.ValueFloat64()

	model := &jsonPanelHeatmapDataSourceModel_Options_Calculation_XBuckets_Scale{
		Type:            attr_type,
		Log:             &attr_log,
		LinearThreshold: &attr_linearthreshold,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_Options_Calculation_XBuckets_Scale) ApplyDefaults() PanelHeatmapDataSourceModel_Options_Calculation_XBuckets_Scale {

	return m
}

type PanelHeatmapDataSourceModel_Options_Calculation_XBuckets struct {
	Mode  types.String                                                    `tfsdk:"mode"`
	Value types.String                                                    `tfsdk:"value"`
	Scale *PanelHeatmapDataSourceModel_Options_Calculation_XBuckets_Scale `tfsdk:"scale"`
}

func (m PanelHeatmapDataSourceModel_Options_Calculation_XBuckets) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_Options_Calculation_XBuckets struct {
		Mode  *string     `json:"mode,omitempty"`
		Value *string     `json:"value,omitempty"`
		Scale interface{} `json:"scale,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_mode := m.Mode.ValueString()
	attr_value := m.Value.ValueString()
	var attr_scale interface{}
	if m.Scale != nil {
		attr_scale = m.Scale
	}

	model := &jsonPanelHeatmapDataSourceModel_Options_Calculation_XBuckets{
		Mode:  &attr_mode,
		Value: &attr_value,
		Scale: attr_scale,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_Options_Calculation_XBuckets) ApplyDefaults() PanelHeatmapDataSourceModel_Options_Calculation_XBuckets {

	return m
}

type PanelHeatmapDataSourceModel_Options_Calculation_YBuckets_Scale struct {
	Type            types.String  `tfsdk:"type"`
	Log             types.Float64 `tfsdk:"log"`
	LinearThreshold types.Float64 `tfsdk:"linear_threshold"`
}

func (m PanelHeatmapDataSourceModel_Options_Calculation_YBuckets_Scale) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_Options_Calculation_YBuckets_Scale struct {
		Type            string   `json:"type"`
		Log             *float64 `json:"log,omitempty"`
		LinearThreshold *float64 `json:"linearThreshold,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_type := m.Type.ValueString()
	attr_log := m.Log.ValueFloat64()
	attr_linearthreshold := m.LinearThreshold.ValueFloat64()

	model := &jsonPanelHeatmapDataSourceModel_Options_Calculation_YBuckets_Scale{
		Type:            attr_type,
		Log:             &attr_log,
		LinearThreshold: &attr_linearthreshold,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_Options_Calculation_YBuckets_Scale) ApplyDefaults() PanelHeatmapDataSourceModel_Options_Calculation_YBuckets_Scale {

	return m
}

type PanelHeatmapDataSourceModel_Options_Calculation_YBuckets struct {
	Mode  types.String                                                    `tfsdk:"mode"`
	Value types.String                                                    `tfsdk:"value"`
	Scale *PanelHeatmapDataSourceModel_Options_Calculation_YBuckets_Scale `tfsdk:"scale"`
}

func (m PanelHeatmapDataSourceModel_Options_Calculation_YBuckets) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_Options_Calculation_YBuckets struct {
		Mode  *string     `json:"mode,omitempty"`
		Value *string     `json:"value,omitempty"`
		Scale interface{} `json:"scale,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_mode := m.Mode.ValueString()
	attr_value := m.Value.ValueString()
	var attr_scale interface{}
	if m.Scale != nil {
		attr_scale = m.Scale
	}

	model := &jsonPanelHeatmapDataSourceModel_Options_Calculation_YBuckets{
		Mode:  &attr_mode,
		Value: &attr_value,
		Scale: attr_scale,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_Options_Calculation_YBuckets) ApplyDefaults() PanelHeatmapDataSourceModel_Options_Calculation_YBuckets {

	return m
}

type PanelHeatmapDataSourceModel_Options_Calculation struct {
	XBuckets *PanelHeatmapDataSourceModel_Options_Calculation_XBuckets `tfsdk:"x_buckets"`
	YBuckets *PanelHeatmapDataSourceModel_Options_Calculation_YBuckets `tfsdk:"y_buckets"`
}

func (m PanelHeatmapDataSourceModel_Options_Calculation) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_Options_Calculation struct {
		XBuckets interface{} `json:"xBuckets,omitempty"`
		YBuckets interface{} `json:"yBuckets,omitempty"`
	}

	m = m.ApplyDefaults()
	var attr_xbuckets interface{}
	if m.XBuckets != nil {
		attr_xbuckets = m.XBuckets
	}
	var attr_ybuckets interface{}
	if m.YBuckets != nil {
		attr_ybuckets = m.YBuckets
	}

	model := &jsonPanelHeatmapDataSourceModel_Options_Calculation{
		XBuckets: attr_xbuckets,
		YBuckets: attr_ybuckets,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_Options_Calculation) ApplyDefaults() PanelHeatmapDataSourceModel_Options_Calculation {

	return m
}

type PanelHeatmapDataSourceModel_Options_Color struct {
	Scheme   types.String  `tfsdk:"scheme"`
	Fill     types.String  `tfsdk:"fill"`
	Reverse  types.Bool    `tfsdk:"reverse"`
	Exponent types.Float64 `tfsdk:"exponent"`
	Steps    types.Int64   `tfsdk:"steps"`
}

func (m PanelHeatmapDataSourceModel_Options_Color) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_Options_Color struct {
		Scheme   string  `json:"scheme"`
		Fill     string  `json:"fill"`
		Reverse  bool    `json:"reverse"`
		Exponent float64 `json:"exponent"`
		Steps    int64   `json:"steps"`
	}

	m = m.ApplyDefaults()
	attr_scheme := m.Scheme.ValueString()
	attr_fill := m.Fill.ValueString()
	attr_reverse := m.Reverse.ValueBool()
	attr_exponent := m.Exponent.ValueFloat64()
	attr_steps := m.Steps.ValueInt64()

	model := &jsonPanelHeatmapDataSourceModel_Options_Color{
		Scheme:   attr_scheme,
		Fill:     attr_fill,
		Reverse:  attr_reverse,
		Exponent: attr_exponent,
		Steps:    attr_steps,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_Options_Color) ApplyDefaults() PanelHeatmapDataSourceModel_Options_Color {

	return m
}

type PanelHeatmapDataSourceModel_Options_FilterValues struct {
	Le types.Float64 `tfsdk:"le"`
}

func (m PanelHeatmapDataSourceModel_Options_FilterValues) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_Options_FilterValues struct {
		Le float64 `json:"le"`
	}

	m = m.ApplyDefaults()
	attr_le := m.Le.ValueFloat64()

	model := &jsonPanelHeatmapDataSourceModel_Options_FilterValues{
		Le: attr_le,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_Options_FilterValues) ApplyDefaults() PanelHeatmapDataSourceModel_Options_FilterValues {

	return m
}

type PanelHeatmapDataSourceModel_Options_RowsFrame struct {
	Value  types.String `tfsdk:"value"`
	Layout types.String `tfsdk:"layout"`
}

func (m PanelHeatmapDataSourceModel_Options_RowsFrame) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_Options_RowsFrame struct {
		Value  *string `json:"value,omitempty"`
		Layout *string `json:"layout,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_value := m.Value.ValueString()
	attr_layout := m.Layout.ValueString()

	model := &jsonPanelHeatmapDataSourceModel_Options_RowsFrame{
		Value:  &attr_value,
		Layout: &attr_layout,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_Options_RowsFrame) ApplyDefaults() PanelHeatmapDataSourceModel_Options_RowsFrame {

	return m
}

type PanelHeatmapDataSourceModel_Options_CellValues struct {
}

func (m PanelHeatmapDataSourceModel_Options_CellValues) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_Options_CellValues struct {
	}

	m = m.ApplyDefaults()

	model := &jsonPanelHeatmapDataSourceModel_Options_CellValues{}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_Options_CellValues) ApplyDefaults() PanelHeatmapDataSourceModel_Options_CellValues {

	return m
}

type PanelHeatmapDataSourceModel_Options_YAxis_ScaleDistribution struct {
	Type            types.String  `tfsdk:"type"`
	Log             types.Float64 `tfsdk:"log"`
	LinearThreshold types.Float64 `tfsdk:"linear_threshold"`
}

func (m PanelHeatmapDataSourceModel_Options_YAxis_ScaleDistribution) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_Options_YAxis_ScaleDistribution struct {
		Type            string   `json:"type"`
		Log             *float64 `json:"log,omitempty"`
		LinearThreshold *float64 `json:"linearThreshold,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_type := m.Type.ValueString()
	attr_log := m.Log.ValueFloat64()
	attr_linearthreshold := m.LinearThreshold.ValueFloat64()

	model := &jsonPanelHeatmapDataSourceModel_Options_YAxis_ScaleDistribution{
		Type:            attr_type,
		Log:             &attr_log,
		LinearThreshold: &attr_linearthreshold,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_Options_YAxis_ScaleDistribution) ApplyDefaults() PanelHeatmapDataSourceModel_Options_YAxis_ScaleDistribution {

	return m
}

type PanelHeatmapDataSourceModel_Options_YAxis struct {
	Unit              types.String                                                 `tfsdk:"unit"`
	Reverse           types.Bool                                                   `tfsdk:"reverse"`
	Decimals          types.Float64                                                `tfsdk:"decimals"`
	Min               types.Float64                                                `tfsdk:"min"`
	AxisPlacement     types.String                                                 `tfsdk:"axis_placement"`
	AxisColorMode     types.String                                                 `tfsdk:"axis_color_mode"`
	AxisLabel         types.String                                                 `tfsdk:"axis_label"`
	AxisWidth         types.Float64                                                `tfsdk:"axis_width"`
	AxisSoftMin       types.Float64                                                `tfsdk:"axis_soft_min"`
	AxisSoftMax       types.Float64                                                `tfsdk:"axis_soft_max"`
	AxisGridShow      types.Bool                                                   `tfsdk:"axis_grid_show"`
	ScaleDistribution *PanelHeatmapDataSourceModel_Options_YAxis_ScaleDistribution `tfsdk:"scale_distribution"`
	Max               types.Float64                                                `tfsdk:"max"`
	AxisCenteredZero  types.Bool                                                   `tfsdk:"axis_centered_zero"`
}

func (m PanelHeatmapDataSourceModel_Options_YAxis) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_Options_YAxis struct {
		Unit              *string     `json:"unit,omitempty"`
		Reverse           *bool       `json:"reverse,omitempty"`
		Decimals          *float64    `json:"decimals,omitempty"`
		Min               *float64    `json:"min,omitempty"`
		AxisPlacement     *string     `json:"axisPlacement,omitempty"`
		AxisColorMode     *string     `json:"axisColorMode,omitempty"`
		AxisLabel         *string     `json:"axisLabel,omitempty"`
		AxisWidth         *float64    `json:"axisWidth,omitempty"`
		AxisSoftMin       *float64    `json:"axisSoftMin,omitempty"`
		AxisSoftMax       *float64    `json:"axisSoftMax,omitempty"`
		AxisGridShow      *bool       `json:"axisGridShow,omitempty"`
		ScaleDistribution interface{} `json:"scaleDistribution,omitempty"`
		Max               *float64    `json:"max,omitempty"`
		AxisCenteredZero  *bool       `json:"axisCenteredZero,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_unit := m.Unit.ValueString()
	attr_reverse := m.Reverse.ValueBool()
	attr_decimals := m.Decimals.ValueFloat64()
	attr_min := m.Min.ValueFloat64()
	attr_axisplacement := m.AxisPlacement.ValueString()
	attr_axiscolormode := m.AxisColorMode.ValueString()
	attr_axislabel := m.AxisLabel.ValueString()
	attr_axiswidth := m.AxisWidth.ValueFloat64()
	attr_axissoftmin := m.AxisSoftMin.ValueFloat64()
	attr_axissoftmax := m.AxisSoftMax.ValueFloat64()
	attr_axisgridshow := m.AxisGridShow.ValueBool()
	var attr_scaledistribution interface{}
	if m.ScaleDistribution != nil {
		attr_scaledistribution = m.ScaleDistribution
	}
	attr_max := m.Max.ValueFloat64()
	attr_axiscenteredzero := m.AxisCenteredZero.ValueBool()

	model := &jsonPanelHeatmapDataSourceModel_Options_YAxis{
		Unit:              &attr_unit,
		Reverse:           &attr_reverse,
		Decimals:          &attr_decimals,
		Min:               &attr_min,
		AxisPlacement:     &attr_axisplacement,
		AxisColorMode:     &attr_axiscolormode,
		AxisLabel:         &attr_axislabel,
		AxisWidth:         &attr_axiswidth,
		AxisSoftMin:       &attr_axissoftmin,
		AxisSoftMax:       &attr_axissoftmax,
		AxisGridShow:      &attr_axisgridshow,
		ScaleDistribution: attr_scaledistribution,
		Max:               &attr_max,
		AxisCenteredZero:  &attr_axiscenteredzero,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_Options_YAxis) ApplyDefaults() PanelHeatmapDataSourceModel_Options_YAxis {

	return m
}

type PanelHeatmapDataSourceModel_Options_Legend struct {
	Show types.Bool `tfsdk:"show"`
}

func (m PanelHeatmapDataSourceModel_Options_Legend) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_Options_Legend struct {
		Show bool `json:"show"`
	}

	m = m.ApplyDefaults()
	attr_show := m.Show.ValueBool()

	model := &jsonPanelHeatmapDataSourceModel_Options_Legend{
		Show: attr_show,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_Options_Legend) ApplyDefaults() PanelHeatmapDataSourceModel_Options_Legend {

	return m
}

type PanelHeatmapDataSourceModel_Options_Tooltip struct {
	Show       types.Bool `tfsdk:"show"`
	YHistogram types.Bool `tfsdk:"y_histogram"`
}

func (m PanelHeatmapDataSourceModel_Options_Tooltip) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_Options_Tooltip struct {
		Show       bool `json:"show"`
		YHistogram bool `json:"yHistogram"`
	}

	m = m.ApplyDefaults()
	attr_show := m.Show.ValueBool()
	attr_yhistogram := m.YHistogram.ValueBool()

	model := &jsonPanelHeatmapDataSourceModel_Options_Tooltip{
		Show:       attr_show,
		YHistogram: attr_yhistogram,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_Options_Tooltip) ApplyDefaults() PanelHeatmapDataSourceModel_Options_Tooltip {

	return m
}

type PanelHeatmapDataSourceModel_Options_Exemplars struct {
	Color types.String `tfsdk:"color"`
}

func (m PanelHeatmapDataSourceModel_Options_Exemplars) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_Options_Exemplars struct {
		Color string `json:"color"`
	}

	m = m.ApplyDefaults()
	attr_color := m.Color.ValueString()

	model := &jsonPanelHeatmapDataSourceModel_Options_Exemplars{
		Color: attr_color,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_Options_Exemplars) ApplyDefaults() PanelHeatmapDataSourceModel_Options_Exemplars {

	return m
}

type PanelHeatmapDataSourceModel_Options struct {
	Calculate    types.Bool                                        `tfsdk:"calculate"`
	Calculation  *PanelHeatmapDataSourceModel_Options_Calculation  `tfsdk:"calculation"`
	Color        *PanelHeatmapDataSourceModel_Options_Color        `tfsdk:"color"`
	FilterValues *PanelHeatmapDataSourceModel_Options_FilterValues `tfsdk:"filter_values"`
	RowsFrame    *PanelHeatmapDataSourceModel_Options_RowsFrame    `tfsdk:"rows_frame"`
	ShowValue    types.String                                      `tfsdk:"show_value"`
	CellGap      types.Int64                                       `tfsdk:"cell_gap"`
	CellRadius   types.Float64                                     `tfsdk:"cell_radius"`
	CellValues   *PanelHeatmapDataSourceModel_Options_CellValues   `tfsdk:"cell_values"`
	YAxis        *PanelHeatmapDataSourceModel_Options_YAxis        `tfsdk:"y_axis"`
	Legend       *PanelHeatmapDataSourceModel_Options_Legend       `tfsdk:"legend"`
	Tooltip      *PanelHeatmapDataSourceModel_Options_Tooltip      `tfsdk:"tooltip"`
	Exemplars    *PanelHeatmapDataSourceModel_Options_Exemplars    `tfsdk:"exemplars"`
}

func (m PanelHeatmapDataSourceModel_Options) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_Options struct {
		Calculate    *bool       `json:"calculate,omitempty"`
		Calculation  interface{} `json:"calculation,omitempty"`
		Color        interface{} `json:"color,omitempty"`
		FilterValues interface{} `json:"filterValues,omitempty"`
		RowsFrame    interface{} `json:"rowsFrame,omitempty"`
		ShowValue    string      `json:"showValue"`
		CellGap      *int64      `json:"cellGap,omitempty"`
		CellRadius   *float64    `json:"cellRadius,omitempty"`
		CellValues   interface{} `json:"cellValues,omitempty"`
		YAxis        interface{} `json:"yAxis,omitempty"`
		Legend       interface{} `json:"legend,omitempty"`
		Tooltip      interface{} `json:"tooltip,omitempty"`
		Exemplars    interface{} `json:"exemplars,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_calculate := m.Calculate.ValueBool()
	var attr_calculation interface{}
	if m.Calculation != nil {
		attr_calculation = m.Calculation
	}
	var attr_color interface{}
	if m.Color != nil {
		attr_color = m.Color
	}
	var attr_filtervalues interface{}
	if m.FilterValues != nil {
		attr_filtervalues = m.FilterValues
	}
	var attr_rowsframe interface{}
	if m.RowsFrame != nil {
		attr_rowsframe = m.RowsFrame
	}
	attr_showvalue := m.ShowValue.ValueString()
	attr_cellgap := m.CellGap.ValueInt64()
	attr_cellradius := m.CellRadius.ValueFloat64()
	var attr_cellvalues interface{}
	if m.CellValues != nil {
		attr_cellvalues = m.CellValues
	}
	var attr_yaxis interface{}
	if m.YAxis != nil {
		attr_yaxis = m.YAxis
	}
	var attr_legend interface{}
	if m.Legend != nil {
		attr_legend = m.Legend
	}
	var attr_tooltip interface{}
	if m.Tooltip != nil {
		attr_tooltip = m.Tooltip
	}
	var attr_exemplars interface{}
	if m.Exemplars != nil {
		attr_exemplars = m.Exemplars
	}

	model := &jsonPanelHeatmapDataSourceModel_Options{
		Calculate:    &attr_calculate,
		Calculation:  attr_calculation,
		Color:        attr_color,
		FilterValues: attr_filtervalues,
		RowsFrame:    attr_rowsframe,
		ShowValue:    attr_showvalue,
		CellGap:      &attr_cellgap,
		CellRadius:   &attr_cellradius,
		CellValues:   attr_cellvalues,
		YAxis:        attr_yaxis,
		Legend:       attr_legend,
		Tooltip:      attr_tooltip,
		Exemplars:    attr_exemplars,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_Options) ApplyDefaults() PanelHeatmapDataSourceModel_Options {
	if m.Calculate.IsNull() {
		m.Calculate = types.BoolValue(false)
	}
	if m.ShowValue.IsNull() {
		m.ShowValue = types.StringValue(`auto`)
	}
	if m.CellGap.IsNull() {
		m.CellGap = types.Int64Value(1)
	}
	return m
}

type PanelHeatmapDataSourceModel_FieldConfig_Defaults_Thresholds_Steps struct {
	Value types.Float64 `tfsdk:"value"`
	Color types.String  `tfsdk:"color"`
	Index types.Int64   `tfsdk:"index"`
	State types.String  `tfsdk:"state"`
}

func (m PanelHeatmapDataSourceModel_FieldConfig_Defaults_Thresholds_Steps) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_FieldConfig_Defaults_Thresholds_Steps struct {
		Value *float64 `json:"value,omitempty"`
		Color string   `json:"color"`
		Index *int64   `json:"index,omitempty"`
		State *string  `json:"state,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_value := m.Value.ValueFloat64()
	attr_color := m.Color.ValueString()
	attr_index := m.Index.ValueInt64()
	attr_state := m.State.ValueString()

	model := &jsonPanelHeatmapDataSourceModel_FieldConfig_Defaults_Thresholds_Steps{
		Value: &attr_value,
		Color: attr_color,
		Index: &attr_index,
		State: &attr_state,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_FieldConfig_Defaults_Thresholds_Steps) ApplyDefaults() PanelHeatmapDataSourceModel_FieldConfig_Defaults_Thresholds_Steps {

	return m
}

type PanelHeatmapDataSourceModel_FieldConfig_Defaults_Thresholds struct {
	Mode  types.String                                                        `tfsdk:"mode"`
	Steps []PanelHeatmapDataSourceModel_FieldConfig_Defaults_Thresholds_Steps `tfsdk:"steps"`
}

func (m PanelHeatmapDataSourceModel_FieldConfig_Defaults_Thresholds) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_FieldConfig_Defaults_Thresholds struct {
		Mode  string        `json:"mode"`
		Steps []interface{} `json:"steps,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_mode := m.Mode.ValueString()
	attr_steps := []interface{}{}
	for _, v := range m.Steps {
		attr_steps = append(attr_steps, v)
	}

	model := &jsonPanelHeatmapDataSourceModel_FieldConfig_Defaults_Thresholds{
		Mode:  attr_mode,
		Steps: attr_steps,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_FieldConfig_Defaults_Thresholds) ApplyDefaults() PanelHeatmapDataSourceModel_FieldConfig_Defaults_Thresholds {

	return m
}

type PanelHeatmapDataSourceModel_FieldConfig_Defaults_Color struct {
	Mode       types.String `tfsdk:"mode"`
	FixedColor types.String `tfsdk:"fixed_color"`
	SeriesBy   types.String `tfsdk:"series_by"`
}

func (m PanelHeatmapDataSourceModel_FieldConfig_Defaults_Color) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_FieldConfig_Defaults_Color struct {
		Mode       string  `json:"mode"`
		FixedColor *string `json:"fixedColor,omitempty"`
		SeriesBy   *string `json:"seriesBy,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_mode := m.Mode.ValueString()
	attr_fixedcolor := m.FixedColor.ValueString()
	attr_seriesby := m.SeriesBy.ValueString()

	model := &jsonPanelHeatmapDataSourceModel_FieldConfig_Defaults_Color{
		Mode:       attr_mode,
		FixedColor: &attr_fixedcolor,
		SeriesBy:   &attr_seriesby,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_FieldConfig_Defaults_Color) ApplyDefaults() PanelHeatmapDataSourceModel_FieldConfig_Defaults_Color {

	return m
}

type PanelHeatmapDataSourceModel_FieldConfig_Defaults_Custom_ScaleDistribution struct {
	Type            types.String  `tfsdk:"type"`
	Log             types.Float64 `tfsdk:"log"`
	LinearThreshold types.Float64 `tfsdk:"linear_threshold"`
}

func (m PanelHeatmapDataSourceModel_FieldConfig_Defaults_Custom_ScaleDistribution) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_FieldConfig_Defaults_Custom_ScaleDistribution struct {
		Type            string   `json:"type"`
		Log             *float64 `json:"log,omitempty"`
		LinearThreshold *float64 `json:"linearThreshold,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_type := m.Type.ValueString()
	attr_log := m.Log.ValueFloat64()
	attr_linearthreshold := m.LinearThreshold.ValueFloat64()

	model := &jsonPanelHeatmapDataSourceModel_FieldConfig_Defaults_Custom_ScaleDistribution{
		Type:            attr_type,
		Log:             &attr_log,
		LinearThreshold: &attr_linearthreshold,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_FieldConfig_Defaults_Custom_ScaleDistribution) ApplyDefaults() PanelHeatmapDataSourceModel_FieldConfig_Defaults_Custom_ScaleDistribution {

	return m
}

type PanelHeatmapDataSourceModel_FieldConfig_Defaults_Custom_HideFrom struct {
	Tooltip types.Bool `tfsdk:"tooltip"`
	Legend  types.Bool `tfsdk:"legend"`
	Viz     types.Bool `tfsdk:"viz"`
}

func (m PanelHeatmapDataSourceModel_FieldConfig_Defaults_Custom_HideFrom) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_FieldConfig_Defaults_Custom_HideFrom struct {
		Tooltip bool `json:"tooltip"`
		Legend  bool `json:"legend"`
		Viz     bool `json:"viz"`
	}

	m = m.ApplyDefaults()
	attr_tooltip := m.Tooltip.ValueBool()
	attr_legend := m.Legend.ValueBool()
	attr_viz := m.Viz.ValueBool()

	model := &jsonPanelHeatmapDataSourceModel_FieldConfig_Defaults_Custom_HideFrom{
		Tooltip: attr_tooltip,
		Legend:  attr_legend,
		Viz:     attr_viz,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_FieldConfig_Defaults_Custom_HideFrom) ApplyDefaults() PanelHeatmapDataSourceModel_FieldConfig_Defaults_Custom_HideFrom {

	return m
}

type PanelHeatmapDataSourceModel_FieldConfig_Defaults_Custom struct {
	ScaleDistribution *PanelHeatmapDataSourceModel_FieldConfig_Defaults_Custom_ScaleDistribution `tfsdk:"scale_distribution"`
	HideFrom          *PanelHeatmapDataSourceModel_FieldConfig_Defaults_Custom_HideFrom          `tfsdk:"hide_from"`
}

func (m PanelHeatmapDataSourceModel_FieldConfig_Defaults_Custom) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_FieldConfig_Defaults_Custom struct {
		ScaleDistribution interface{} `json:"scaleDistribution,omitempty"`
		HideFrom          interface{} `json:"hideFrom,omitempty"`
	}

	m = m.ApplyDefaults()
	var attr_scaledistribution interface{}
	if m.ScaleDistribution != nil {
		attr_scaledistribution = m.ScaleDistribution
	}
	var attr_hidefrom interface{}
	if m.HideFrom != nil {
		attr_hidefrom = m.HideFrom
	}

	model := &jsonPanelHeatmapDataSourceModel_FieldConfig_Defaults_Custom{
		ScaleDistribution: attr_scaledistribution,
		HideFrom:          attr_hidefrom,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_FieldConfig_Defaults_Custom) ApplyDefaults() PanelHeatmapDataSourceModel_FieldConfig_Defaults_Custom {

	return m
}

type PanelHeatmapDataSourceModel_FieldConfig_Defaults struct {
	DisplayName       types.String                                                 `tfsdk:"display_name"`
	DisplayNameFromDS types.String                                                 `tfsdk:"display_name_from_ds"`
	Description       types.String                                                 `tfsdk:"description"`
	Path              types.String                                                 `tfsdk:"path"`
	Writeable         types.Bool                                                   `tfsdk:"writeable"`
	Filterable        types.Bool                                                   `tfsdk:"filterable"`
	Unit              types.String                                                 `tfsdk:"unit"`
	Decimals          types.Float64                                                `tfsdk:"decimals"`
	Min               types.Float64                                                `tfsdk:"min"`
	Max               types.Float64                                                `tfsdk:"max"`
	Thresholds        *PanelHeatmapDataSourceModel_FieldConfig_Defaults_Thresholds `tfsdk:"thresholds"`
	Color             *PanelHeatmapDataSourceModel_FieldConfig_Defaults_Color      `tfsdk:"color"`
	NoValue           types.String                                                 `tfsdk:"no_value"`
	Custom            *PanelHeatmapDataSourceModel_FieldConfig_Defaults_Custom     `tfsdk:"custom"`
}

func (m PanelHeatmapDataSourceModel_FieldConfig_Defaults) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_FieldConfig_Defaults struct {
		DisplayName       *string     `json:"displayName,omitempty"`
		DisplayNameFromDS *string     `json:"displayNameFromDS,omitempty"`
		Description       *string     `json:"description,omitempty"`
		Path              *string     `json:"path,omitempty"`
		Writeable         *bool       `json:"writeable,omitempty"`
		Filterable        *bool       `json:"filterable,omitempty"`
		Unit              *string     `json:"unit,omitempty"`
		Decimals          *float64    `json:"decimals,omitempty"`
		Min               *float64    `json:"min,omitempty"`
		Max               *float64    `json:"max,omitempty"`
		Thresholds        interface{} `json:"thresholds,omitempty"`
		Color             interface{} `json:"color,omitempty"`
		NoValue           *string     `json:"noValue,omitempty"`
		Custom            interface{} `json:"custom,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_displayname := m.DisplayName.ValueString()
	attr_displaynamefromds := m.DisplayNameFromDS.ValueString()
	attr_description := m.Description.ValueString()
	attr_path := m.Path.ValueString()
	attr_writeable := m.Writeable.ValueBool()
	attr_filterable := m.Filterable.ValueBool()
	attr_unit := m.Unit.ValueString()
	attr_decimals := m.Decimals.ValueFloat64()
	attr_min := m.Min.ValueFloat64()
	attr_max := m.Max.ValueFloat64()
	var attr_thresholds interface{}
	if m.Thresholds != nil {
		attr_thresholds = m.Thresholds
	}
	var attr_color interface{}
	if m.Color != nil {
		attr_color = m.Color
	}
	attr_novalue := m.NoValue.ValueString()
	var attr_custom interface{}
	if m.Custom != nil {
		attr_custom = m.Custom
	}

	model := &jsonPanelHeatmapDataSourceModel_FieldConfig_Defaults{
		DisplayName:       &attr_displayname,
		DisplayNameFromDS: &attr_displaynamefromds,
		Description:       &attr_description,
		Path:              &attr_path,
		Writeable:         &attr_writeable,
		Filterable:        &attr_filterable,
		Unit:              &attr_unit,
		Decimals:          &attr_decimals,
		Min:               &attr_min,
		Max:               &attr_max,
		Thresholds:        attr_thresholds,
		Color:             attr_color,
		NoValue:           &attr_novalue,
		Custom:            attr_custom,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_FieldConfig_Defaults) ApplyDefaults() PanelHeatmapDataSourceModel_FieldConfig_Defaults {

	return m
}

type PanelHeatmapDataSourceModel_FieldConfig_Overrides_Matcher struct {
}

func (m PanelHeatmapDataSourceModel_FieldConfig_Overrides_Matcher) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_FieldConfig_Overrides_Matcher struct {
	}

	m = m.ApplyDefaults()

	model := &jsonPanelHeatmapDataSourceModel_FieldConfig_Overrides_Matcher{}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_FieldConfig_Overrides_Matcher) ApplyDefaults() PanelHeatmapDataSourceModel_FieldConfig_Overrides_Matcher {

	return m
}

type PanelHeatmapDataSourceModel_FieldConfig_Overrides_Properties struct {
}

func (m PanelHeatmapDataSourceModel_FieldConfig_Overrides_Properties) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_FieldConfig_Overrides_Properties struct {
	}

	m = m.ApplyDefaults()

	model := &jsonPanelHeatmapDataSourceModel_FieldConfig_Overrides_Properties{}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_FieldConfig_Overrides_Properties) ApplyDefaults() PanelHeatmapDataSourceModel_FieldConfig_Overrides_Properties {

	return m
}

type PanelHeatmapDataSourceModel_FieldConfig_Overrides struct {
	Matcher    *PanelHeatmapDataSourceModel_FieldConfig_Overrides_Matcher     `tfsdk:"matcher"`
	Properties []PanelHeatmapDataSourceModel_FieldConfig_Overrides_Properties `tfsdk:"properties"`
}

func (m PanelHeatmapDataSourceModel_FieldConfig_Overrides) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_FieldConfig_Overrides struct {
		Matcher    interface{}   `json:"matcher,omitempty"`
		Properties []interface{} `json:"properties,omitempty"`
	}

	m = m.ApplyDefaults()
	var attr_matcher interface{}
	if m.Matcher != nil {
		attr_matcher = m.Matcher
	}
	attr_properties := []interface{}{}
	for _, v := range m.Properties {
		attr_properties = append(attr_properties, v)
	}

	model := &jsonPanelHeatmapDataSourceModel_FieldConfig_Overrides{
		Matcher:    attr_matcher,
		Properties: attr_properties,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_FieldConfig_Overrides) ApplyDefaults() PanelHeatmapDataSourceModel_FieldConfig_Overrides {

	return m
}

type PanelHeatmapDataSourceModel_FieldConfig struct {
	Defaults  *PanelHeatmapDataSourceModel_FieldConfig_Defaults   `tfsdk:"defaults"`
	Overrides []PanelHeatmapDataSourceModel_FieldConfig_Overrides `tfsdk:"overrides"`
}

func (m PanelHeatmapDataSourceModel_FieldConfig) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel_FieldConfig struct {
		Defaults  interface{}   `json:"defaults,omitempty"`
		Overrides []interface{} `json:"overrides,omitempty"`
	}

	m = m.ApplyDefaults()
	var attr_defaults interface{}
	if m.Defaults != nil {
		attr_defaults = m.Defaults
	}
	attr_overrides := []interface{}{}
	for _, v := range m.Overrides {
		attr_overrides = append(attr_overrides, v)
	}

	model := &jsonPanelHeatmapDataSourceModel_FieldConfig{
		Defaults:  attr_defaults,
		Overrides: attr_overrides,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel_FieldConfig) ApplyDefaults() PanelHeatmapDataSourceModel_FieldConfig {

	return m
}

type PanelHeatmapDataSourceModel struct {
	ToJSON          types.String                                  `tfsdk:"to_json"`
	Type            types.String                                  `tfsdk:"type"`
	PluginVersion   types.String                                  `tfsdk:"plugin_version"`
	Tags            types.List                                    `tfsdk:"tags"`
	Targets         types.List                                    `tfsdk:"targets"`
	Title           types.String                                  `tfsdk:"title"`
	Description     types.String                                  `tfsdk:"description"`
	Transparent     types.Bool                                    `tfsdk:"transparent"`
	Datasource      *PanelHeatmapDataSourceModel_Datasource       `tfsdk:"datasource"`
	GridPos         *PanelHeatmapDataSourceModel_GridPos          `tfsdk:"grid_pos"`
	Links           []PanelHeatmapDataSourceModel_Links           `tfsdk:"links"`
	Repeat          types.String                                  `tfsdk:"repeat"`
	RepeatDirection types.String                                  `tfsdk:"repeat_direction"`
	RepeatPanelId   types.Int64                                   `tfsdk:"repeat_panel_id"`
	MaxDataPoints   types.Float64                                 `tfsdk:"max_data_points"`
	Transformations []PanelHeatmapDataSourceModel_Transformations `tfsdk:"transformations"`
	Interval        types.String                                  `tfsdk:"interval"`
	TimeFrom        types.String                                  `tfsdk:"time_from"`
	TimeShift       types.String                                  `tfsdk:"time_shift"`
	LibraryPanel    *PanelHeatmapDataSourceModel_LibraryPanel     `tfsdk:"library_panel"`
	Options         *PanelHeatmapDataSourceModel_Options          `tfsdk:"options"`
	FieldConfig     *PanelHeatmapDataSourceModel_FieldConfig      `tfsdk:"field_config"`
}

func (m PanelHeatmapDataSourceModel) MarshalJSON() ([]byte, error) {
	type jsonPanelHeatmapDataSourceModel struct {
		Type            string        `json:"type"`
		PluginVersion   *string       `json:"pluginVersion,omitempty"`
		Tags            []string      `json:"tags,omitempty"`
		Targets         []string      `json:"targets,omitempty"`
		Title           *string       `json:"title,omitempty"`
		Description     *string       `json:"description,omitempty"`
		Transparent     bool          `json:"transparent"`
		Datasource      interface{}   `json:"datasource,omitempty"`
		GridPos         interface{}   `json:"gridPos,omitempty"`
		Links           []interface{} `json:"links,omitempty"`
		Repeat          *string       `json:"repeat,omitempty"`
		RepeatDirection string        `json:"repeatDirection"`
		RepeatPanelId   *int64        `json:"repeatPanelId,omitempty"`
		MaxDataPoints   *float64      `json:"maxDataPoints,omitempty"`
		Transformations []interface{} `json:"transformations,omitempty"`
		Interval        *string       `json:"interval,omitempty"`
		TimeFrom        *string       `json:"timeFrom,omitempty"`
		TimeShift       *string       `json:"timeShift,omitempty"`
		LibraryPanel    interface{}   `json:"libraryPanel,omitempty"`
		Options         interface{}   `json:"options,omitempty"`
		FieldConfig     interface{}   `json:"fieldConfig,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_type := m.Type.ValueString()
	attr_pluginversion := m.PluginVersion.ValueString()
	attr_tags := []string{}
	for _, v := range m.Tags.Elements() {
		attr_tags = append(attr_tags, v.(types.String).ValueString())
	}
	attr_targets := []string{}
	for _, v := range m.Targets.Elements() {
		attr_targets = append(attr_targets, v.(types.String).ValueString())
	}
	attr_title := m.Title.ValueString()
	attr_description := m.Description.ValueString()
	attr_transparent := m.Transparent.ValueBool()
	var attr_datasource interface{}
	if m.Datasource != nil {
		attr_datasource = m.Datasource
	}
	var attr_gridpos interface{}
	if m.GridPos != nil {
		attr_gridpos = m.GridPos
	}
	attr_links := []interface{}{}
	for _, v := range m.Links {
		attr_links = append(attr_links, v)
	}
	attr_repeat := m.Repeat.ValueString()
	attr_repeatdirection := m.RepeatDirection.ValueString()
	attr_repeatpanelid := m.RepeatPanelId.ValueInt64()
	attr_maxdatapoints := m.MaxDataPoints.ValueFloat64()
	attr_transformations := []interface{}{}
	for _, v := range m.Transformations {
		attr_transformations = append(attr_transformations, v)
	}
	attr_interval := m.Interval.ValueString()
	attr_timefrom := m.TimeFrom.ValueString()
	attr_timeshift := m.TimeShift.ValueString()
	var attr_librarypanel interface{}
	if m.LibraryPanel != nil {
		attr_librarypanel = m.LibraryPanel
	}
	var attr_options interface{}
	if m.Options != nil {
		attr_options = m.Options
	}
	var attr_fieldconfig interface{}
	if m.FieldConfig != nil {
		attr_fieldconfig = m.FieldConfig
	}

	model := &jsonPanelHeatmapDataSourceModel{
		Type:            attr_type,
		PluginVersion:   &attr_pluginversion,
		Tags:            attr_tags,
		Targets:         attr_targets,
		Title:           &attr_title,
		Description:     &attr_description,
		Transparent:     attr_transparent,
		Datasource:      attr_datasource,
		GridPos:         attr_gridpos,
		Links:           attr_links,
		Repeat:          &attr_repeat,
		RepeatDirection: attr_repeatdirection,
		RepeatPanelId:   &attr_repeatpanelid,
		MaxDataPoints:   &attr_maxdatapoints,
		Transformations: attr_transformations,
		Interval:        &attr_interval,
		TimeFrom:        &attr_timefrom,
		TimeShift:       &attr_timeshift,
		LibraryPanel:    attr_librarypanel,
		Options:         attr_options,
		FieldConfig:     attr_fieldconfig,
	}
	return json.Marshal(model)
}

func (m PanelHeatmapDataSourceModel) ApplyDefaults() PanelHeatmapDataSourceModel {
	if m.Type.IsNull() {
		m.Type = types.StringValue(`heatmap`)
	}
	if len(m.Tags.Elements()) == 0 {
		m.Tags, _ = types.ListValue(types.StringType, []attr.Value{})
	}
	if len(m.Targets.Elements()) == 0 {
		m.Targets, _ = types.ListValue(types.StringType, []attr.Value{})
	}
	if m.Transparent.IsNull() {
		m.Transparent = types.BoolValue(false)
	}
	if m.RepeatDirection.IsNull() {
		m.RepeatDirection = types.StringValue(`h`)
	}
	return m
}

func (d *PanelHeatmapDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_panel_heatmap"
}

func (d *PanelHeatmapDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "TODO description",
		Attributes: map[string]schema.Attribute{
			"type": schema.StringAttribute{
				MarkdownDescription: `The panel plugin type id. May not be empty. Defaults to "heatmap".`,
				Computed:            true,
				Optional:            true,
				Required:            false,
			},
			"plugin_version": schema.StringAttribute{
				MarkdownDescription: `FIXME this almost certainly has to be changed in favor of scuemata versions`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"tags": schema.ListAttribute{
				MarkdownDescription: `TODO docs`,
				Computed:            false,
				Optional:            true,
				Required:            false,
				ElementType:         types.StringType,
			},
			"targets": schema.ListAttribute{
				MarkdownDescription: `TODO docs`,
				Computed:            false,
				Optional:            true,
				Required:            false,
				ElementType:         types.StringType,
			},
			"title": schema.StringAttribute{
				MarkdownDescription: `Panel title.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: `Description.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"transparent": schema.BoolAttribute{
				MarkdownDescription: `Whether to display the panel without a background. Defaults to false.`,
				Computed:            true,
				Optional:            true,
				Required:            false,
			},
			"datasource": schema.SingleNestedAttribute{
				MarkdownDescription: `The datasource used in all targets.`,
				Computed:            true,
				Optional:            true,
				Required:            false,
				Attributes: map[string]schema.Attribute{
					"type": schema.StringAttribute{
						MarkdownDescription: ``,
						Computed:            false,
						Optional:            true,
						Required:            false,
					},
					"uid": schema.StringAttribute{
						MarkdownDescription: ``,
						Computed:            false,
						Optional:            true,
						Required:            false,
					},
				},
			},
			"grid_pos": schema.SingleNestedAttribute{
				MarkdownDescription: `Grid position.`,
				Computed:            true,
				Optional:            true,
				Required:            false,
				Attributes: map[string]schema.Attribute{
					"h": schema.Int64Attribute{
						MarkdownDescription: `Panel. Defaults to 9.`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"w": schema.Int64Attribute{
						MarkdownDescription: `Panel. Defaults to 12.`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"x": schema.Int64Attribute{
						MarkdownDescription: `Panel x. Defaults to 0.`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"y": schema.Int64Attribute{
						MarkdownDescription: `Panel y. Defaults to 0.`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"static": schema.BoolAttribute{
						MarkdownDescription: `true if fixed`,
						Computed:            false,
						Optional:            true,
						Required:            false,
					},
				},
			},
			"links": schema.ListNestedAttribute{
				MarkdownDescription: `Panel links.
TODO fill this out - seems there are a couple variants?`,
				Computed: false,
				Optional: true,
				Required: false,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"title": schema.StringAttribute{
							MarkdownDescription: ``,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"type": schema.StringAttribute{
							MarkdownDescription: ``,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"icon": schema.StringAttribute{
							MarkdownDescription: ``,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"tooltip": schema.StringAttribute{
							MarkdownDescription: ``,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"url": schema.StringAttribute{
							MarkdownDescription: ``,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"tags": schema.ListAttribute{
							MarkdownDescription: ``,
							Computed:            false,
							Optional:            true,
							Required:            false,
							ElementType:         types.StringType,
						},
						"as_dropdown": schema.BoolAttribute{
							MarkdownDescription: ` Defaults to false.`,
							Computed:            true,
							Optional:            true,
							Required:            false,
						},
						"target_blank": schema.BoolAttribute{
							MarkdownDescription: ` Defaults to false.`,
							Computed:            true,
							Optional:            true,
							Required:            false,
						},
						"include_vars": schema.BoolAttribute{
							MarkdownDescription: ` Defaults to false.`,
							Computed:            true,
							Optional:            true,
							Required:            false,
						},
						"keep_time": schema.BoolAttribute{
							MarkdownDescription: ` Defaults to false.`,
							Computed:            true,
							Optional:            true,
							Required:            false,
						},
					},
				},
			},
			"repeat": schema.StringAttribute{
				MarkdownDescription: `Name of template variable to repeat for.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"repeat_direction": schema.StringAttribute{
				MarkdownDescription: `Direction to repeat in if 'repeat' is set.
"h" for horizontal, "v" for vertical.
TODO this is probably optional. Defaults to "h".`,
				Computed: true,
				Optional: true,
				Required: false,
			},
			"repeat_panel_id": schema.Int64Attribute{
				MarkdownDescription: `Id of the repeating panel.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"max_data_points": schema.Float64Attribute{
				MarkdownDescription: `TODO docs`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"transformations": schema.ListNestedAttribute{
				MarkdownDescription: ``,
				Computed:            false,
				Optional:            true,
				Required:            false,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"disabled": schema.BoolAttribute{
							MarkdownDescription: `Disabled transformations are skipped`,
							Computed:            false,
							Optional:            true,
							Required:            false,
						},
						"filter": schema.SingleNestedAttribute{
							MarkdownDescription: `Optional frame matcher.  When missing it will be applied to all results`,
							Computed:            true,
							Optional:            true,
							Required:            false,
						},
					},
				},
			},
			"interval": schema.StringAttribute{
				MarkdownDescription: `TODO docs
TODO tighter constraint`,
				Computed: false,
				Optional: true,
				Required: false,
			},
			"time_from": schema.StringAttribute{
				MarkdownDescription: `TODO docs
TODO tighter constraint`,
				Computed: false,
				Optional: true,
				Required: false,
			},
			"time_shift": schema.StringAttribute{
				MarkdownDescription: `TODO docs
TODO tighter constraint`,
				Computed: false,
				Optional: true,
				Required: false,
			},
			"library_panel": schema.SingleNestedAttribute{
				MarkdownDescription: `Dynamically load the panel`,
				Computed:            true,
				Optional:            true,
				Required:            false,
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: ``,
						Computed:            false,
						Optional:            false,
						Required:            true,
					},
					"uid": schema.StringAttribute{
						MarkdownDescription: ``,
						Computed:            false,
						Optional:            false,
						Required:            true,
					},
				},
			},
			"options": schema.SingleNestedAttribute{
				MarkdownDescription: ``,
				Computed:            true,
				Optional:            true,
				Required:            false,
				Attributes: map[string]schema.Attribute{
					"calculate": schema.BoolAttribute{
						MarkdownDescription: `Controls if the heatmap should be calculated from data. Defaults to false.`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"calculation": schema.SingleNestedAttribute{
						MarkdownDescription: `Calculation options for the heatmap`,
						Computed:            true,
						Optional:            true,
						Required:            false,
						Attributes: map[string]schema.Attribute{
							"x_buckets": schema.SingleNestedAttribute{
								MarkdownDescription: `The number of buckets to use for the xAxis in the heatmap`,
								Computed:            true,
								Optional:            true,
								Required:            false,
								Attributes: map[string]schema.Attribute{
									"mode": schema.StringAttribute{
										MarkdownDescription: `Sets the bucket calculation mode`,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"value": schema.StringAttribute{
										MarkdownDescription: `The number of buckets to use for the axis in the heatmap`,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"scale": schema.SingleNestedAttribute{
										MarkdownDescription: `Controls the scale of the buckets`,
										Computed:            true,
										Optional:            true,
										Required:            false,
										Attributes: map[string]schema.Attribute{
											"type": schema.StringAttribute{
												MarkdownDescription: ``,
												Computed:            false,
												Optional:            false,
												Required:            true,
											},
											"log": schema.Float64Attribute{
												MarkdownDescription: ``,
												Computed:            false,
												Optional:            true,
												Required:            false,
											},
											"linear_threshold": schema.Float64Attribute{
												MarkdownDescription: ``,
												Computed:            false,
												Optional:            true,
												Required:            false,
											},
										},
									},
								},
							},
							"y_buckets": schema.SingleNestedAttribute{
								MarkdownDescription: `The number of buckets to use for the yAxis in the heatmap`,
								Computed:            true,
								Optional:            true,
								Required:            false,
								Attributes: map[string]schema.Attribute{
									"mode": schema.StringAttribute{
										MarkdownDescription: `Sets the bucket calculation mode`,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"value": schema.StringAttribute{
										MarkdownDescription: `The number of buckets to use for the axis in the heatmap`,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"scale": schema.SingleNestedAttribute{
										MarkdownDescription: `Controls the scale of the buckets`,
										Computed:            true,
										Optional:            true,
										Required:            false,
										Attributes: map[string]schema.Attribute{
											"type": schema.StringAttribute{
												MarkdownDescription: ``,
												Computed:            false,
												Optional:            false,
												Required:            true,
											},
											"log": schema.Float64Attribute{
												MarkdownDescription: ``,
												Computed:            false,
												Optional:            true,
												Required:            false,
											},
											"linear_threshold": schema.Float64Attribute{
												MarkdownDescription: ``,
												Computed:            false,
												Optional:            true,
												Required:            false,
											},
										},
									},
								},
							},
						},
					},
					"color": schema.SingleNestedAttribute{
						MarkdownDescription: `Controls the color options`,
						Computed:            true,
						Optional:            true,
						Required:            false,
						Attributes: map[string]schema.Attribute{
							"scheme": schema.StringAttribute{
								MarkdownDescription: `mode:     HeatmapColorMode // TODO: fix after remove when https://github.com/grafana/cuetsy/issues/74 is fixed`,
								Computed:            false,
								Optional:            false,
								Required:            true,
							},
							"fill": schema.StringAttribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            false,
								Required:            true,
							},
							"reverse": schema.BoolAttribute{
								MarkdownDescription: `scale:    HeatmapColorScale // TODO: fix after remove when https://github.com/grafana/cuetsy/issues/74 is fixed`,
								Computed:            false,
								Optional:            false,
								Required:            true,
							},
							"exponent": schema.Float64Attribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            false,
								Required:            true,
							},
							"steps": schema.Int64Attribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            false,
								Required:            true,
							},
						},
					},
					"filter_values": schema.SingleNestedAttribute{
						MarkdownDescription: `Filters values between a given range`,
						Computed:            true,
						Optional:            true,
						Required:            false,
						Attributes: map[string]schema.Attribute{
							"le": schema.Float64Attribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            false,
								Required:            true,
							},
						},
					},
					"rows_frame": schema.SingleNestedAttribute{
						MarkdownDescription: `Controls tick alignment and value name when not calculating from data`,
						Computed:            true,
						Optional:            true,
						Required:            false,
						Attributes: map[string]schema.Attribute{
							"value": schema.StringAttribute{
								MarkdownDescription: `Sets the name of the cell when not calculating from data`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"layout": schema.StringAttribute{
								MarkdownDescription: `Controls tick alignment when not calculating from data`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
						},
					},
					"show_value": schema.StringAttribute{
						MarkdownDescription: `| *{
	layout: ui.HeatmapCellLayout & "auto" // TODO: fix after remove when https://github.com/grafana/cuetsy/issues/74 is fixed
}
Controls the display of the value in the cell. Defaults to "auto".`,
						Computed: true,
						Optional: true,
						Required: false,
					},
					"cell_gap": schema.Int64Attribute{
						MarkdownDescription: `Controls gap between cells. Defaults to 1.`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"cell_radius": schema.Float64Attribute{
						MarkdownDescription: `Controls cell radius`,
						Computed:            false,
						Optional:            true,
						Required:            false,
					},
					"cell_values": schema.SingleNestedAttribute{
						MarkdownDescription: `Controls cell value unit`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"y_axis": schema.SingleNestedAttribute{
						MarkdownDescription: `Controls yAxis placement`,
						Computed:            true,
						Optional:            true,
						Required:            false,
						Attributes: map[string]schema.Attribute{
							"unit": schema.StringAttribute{
								MarkdownDescription: `Sets the yAxis unit`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"reverse": schema.BoolAttribute{
								MarkdownDescription: `Reverses the yAxis`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"decimals": schema.Float64Attribute{
								MarkdownDescription: `Controls the number of decimals for yAxis values`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"min": schema.Float64Attribute{
								MarkdownDescription: `Sets the minimum value for the yAxis`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"axis_placement": schema.StringAttribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"axis_color_mode": schema.StringAttribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"axis_label": schema.StringAttribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"axis_width": schema.Float64Attribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"axis_soft_min": schema.Float64Attribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"axis_soft_max": schema.Float64Attribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"axis_grid_show": schema.BoolAttribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"scale_distribution": schema.SingleNestedAttribute{
								MarkdownDescription: ``,
								Computed:            true,
								Optional:            true,
								Required:            false,
								Attributes: map[string]schema.Attribute{
									"type": schema.StringAttribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            false,
										Required:            true,
									},
									"log": schema.Float64Attribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"linear_threshold": schema.Float64Attribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
								},
							},
							"max": schema.Float64Attribute{
								MarkdownDescription: `Sets the maximum value for the yAxis`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"axis_centered_zero": schema.BoolAttribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
						},
					},
					"legend": schema.SingleNestedAttribute{
						MarkdownDescription: `| *{
	axisPlacement: ui.AxisPlacement & "left" // TODO: fix after remove when https://github.com/grafana/cuetsy/issues/74 is fixed
}
Controls legend options`,
						Computed: true,
						Optional: true,
						Required: false,
						Attributes: map[string]schema.Attribute{
							"show": schema.BoolAttribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            false,
								Required:            true,
							},
						},
					},
					"tooltip": schema.SingleNestedAttribute{
						MarkdownDescription: `Controls tooltip options`,
						Computed:            true,
						Optional:            true,
						Required:            false,
						Attributes: map[string]schema.Attribute{
							"show": schema.BoolAttribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            false,
								Required:            true,
							},
							"y_histogram": schema.BoolAttribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            false,
								Required:            true,
							},
						},
					},
					"exemplars": schema.SingleNestedAttribute{
						MarkdownDescription: `Controls exemplar options`,
						Computed:            true,
						Optional:            true,
						Required:            false,
						Attributes: map[string]schema.Attribute{
							"color": schema.StringAttribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            false,
								Required:            true,
							},
						},
					},
				},
			},
			"field_config": schema.SingleNestedAttribute{
				MarkdownDescription: ``,
				Computed:            true,
				Optional:            true,
				Required:            false,
				Attributes: map[string]schema.Attribute{
					"defaults": schema.SingleNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						Optional:            true,
						Required:            false,
						Attributes: map[string]schema.Attribute{
							"display_name": schema.StringAttribute{
								MarkdownDescription: `The display value for this field.  This supports template variables blank is auto`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"display_name_from_ds": schema.StringAttribute{
								MarkdownDescription: `This can be used by data sources that return and explicit naming structure for values and labels
When this property is configured, this value is used rather than the default naming strategy.`,
								Computed: false,
								Optional: true,
								Required: false,
							},
							"description": schema.StringAttribute{
								MarkdownDescription: `Human readable field metadata`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"path": schema.StringAttribute{
								MarkdownDescription: `An explicit path to the field in the datasource.  When the frame meta includes a path,
This will default to ${frame.meta.path}/${field.name}

When defined, this value can be used as an identifier within the datasource scope, and
may be used to update the results`,
								Computed: false,
								Optional: true,
								Required: false,
							},
							"writeable": schema.BoolAttribute{
								MarkdownDescription: `True if data source can write a value to the path.  Auth/authz are supported separately`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"filterable": schema.BoolAttribute{
								MarkdownDescription: `True if data source field supports ad-hoc filters`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"unit": schema.StringAttribute{
								MarkdownDescription: `Numeric Options`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"decimals": schema.Float64Attribute{
								MarkdownDescription: `Significant digits (for display)`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"min": schema.Float64Attribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"max": schema.Float64Attribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"thresholds": schema.SingleNestedAttribute{
								MarkdownDescription: `Map numeric values to states`,
								Computed:            true,
								Optional:            true,
								Required:            false,
								Attributes: map[string]schema.Attribute{
									"mode": schema.StringAttribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            false,
										Required:            true,
									},
									"steps": schema.ListNestedAttribute{
										MarkdownDescription: `Must be sorted by 'value', first value is always -Infinity`,
										Computed:            false,
										Optional:            true,
										Required:            false,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"value": schema.Float64Attribute{
													MarkdownDescription: `TODO docs
FIXME the corresponding typescript field is required/non-optional, but nulls currently appear here when serializing -Infinity to JSON`,
													Computed: false,
													Optional: true,
													Required: false,
												},
												"color": schema.StringAttribute{
													MarkdownDescription: `TODO docs`,
													Computed:            false,
													Optional:            false,
													Required:            true,
												},
												"index": schema.Int64Attribute{
													MarkdownDescription: `Threshold index, an old property that is not needed an should only appear in older dashboards`,
													Computed:            false,
													Optional:            true,
													Required:            false,
												},
												"state": schema.StringAttribute{
													MarkdownDescription: `TODO docs
TODO are the values here enumerable into a disjunction?
Some seem to be listed in typescript comment`,
													Computed: false,
													Optional: true,
													Required: false,
												},
											},
										},
									},
								},
							},
							"color": schema.SingleNestedAttribute{
								MarkdownDescription: `Map values to a display color`,
								Computed:            true,
								Optional:            true,
								Required:            false,
								Attributes: map[string]schema.Attribute{
									"mode": schema.StringAttribute{
										MarkdownDescription: `The main color scheme mode`,
										Computed:            false,
										Optional:            false,
										Required:            true,
									},
									"fixed_color": schema.StringAttribute{
										MarkdownDescription: `Stores the fixed color value if mode is fixed`,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"series_by": schema.StringAttribute{
										MarkdownDescription: `Some visualizations need to know how to assign a series color from by value color schemes`,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
								},
							},
							"no_value": schema.StringAttribute{
								MarkdownDescription: `Alternative to empty string`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"custom": schema.SingleNestedAttribute{
								MarkdownDescription: ``,
								Computed:            true,
								Optional:            true,
								Required:            false,
								Attributes: map[string]schema.Attribute{
									"scale_distribution": schema.SingleNestedAttribute{
										MarkdownDescription: ``,
										Computed:            true,
										Optional:            true,
										Required:            false,
										Attributes: map[string]schema.Attribute{
											"type": schema.StringAttribute{
												MarkdownDescription: ``,
												Computed:            false,
												Optional:            false,
												Required:            true,
											},
											"log": schema.Float64Attribute{
												MarkdownDescription: ``,
												Computed:            false,
												Optional:            true,
												Required:            false,
											},
											"linear_threshold": schema.Float64Attribute{
												MarkdownDescription: ``,
												Computed:            false,
												Optional:            true,
												Required:            false,
											},
										},
									},
									"hide_from": schema.SingleNestedAttribute{
										MarkdownDescription: ``,
										Computed:            true,
										Optional:            true,
										Required:            false,
										Attributes: map[string]schema.Attribute{
											"tooltip": schema.BoolAttribute{
												MarkdownDescription: ``,
												Computed:            false,
												Optional:            false,
												Required:            true,
											},
											"legend": schema.BoolAttribute{
												MarkdownDescription: ``,
												Computed:            false,
												Optional:            false,
												Required:            true,
											},
											"viz": schema.BoolAttribute{
												MarkdownDescription: ``,
												Computed:            false,
												Optional:            false,
												Required:            true,
											},
										},
									},
								},
							},
						},
					},
					"overrides": schema.ListNestedAttribute{
						MarkdownDescription: ``,
						Computed:            false,
						Optional:            true,
						Required:            false,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"matcher": schema.SingleNestedAttribute{
									MarkdownDescription: ``,
									Computed:            true,
									Optional:            true,
									Required:            false,
								},
								"properties": schema.ListNestedAttribute{
									MarkdownDescription: ``,
									Computed:            false,
									Optional:            true,
									Required:            false,
								},
							},
						},
					},
				},
			},

			"to_json": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "This datasource rendered as JSON",
			},
		},
	}
}

func (d *PanelHeatmapDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
}

func (d *PanelHeatmapDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var data PanelHeatmapDataSourceModel

	// Read Terraform configuration data into the model
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	JSONConfig, err := json.Marshal(data)
	if err != nil {
		resp.Diagnostics.AddError("JSON marshalling error", err.Error())
		return
	}

	// fix up the targets Attribute
	// Read into a map[string]interface{} and then marshal it back to JSON
	// This is a workaround for the fact that the targets attribute should be a list of maps but is a list of json strings
	dataMap := make(map[string]interface{})
	err = json.Unmarshal(JSONConfig, &dataMap)
	if err != nil {
		resp.Diagnostics.AddError("error unmarshalling config into Go map", err.Error())
		return
	}
	targets := data.Targets.Elements()
	targetsMaps := make([]map[string]interface{}, len(targets))
	for i, target := range targets {
		targetMap := make(map[string]interface{})
		err = json.Unmarshal([]byte(target.(types.String).ValueString()), &targetMap)
		if err != nil {
			resp.Diagnostics.AddError("error unmarshalling target into go map", err.Error())
			return
		}
		targetsMaps[i] = targetMap
	}

	dataMap["targets"] = targetsMaps
	JSONConfig, err = json.MarshalIndent(dataMap, "", "  ")
	if err != nil {
		resp.Diagnostics.AddError("error marshalling go map into json", err.Error())
		return
	}

	// Not sure about that
	data.ToJSON = types.StringValue(string(JSONConfig))

	// Write logs using the tflog package
	// Documentation: https://terraform.io/plugin/log
	tflog.Trace(ctx, "read a data source")

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}
