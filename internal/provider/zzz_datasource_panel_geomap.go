// Code generated - EDITING IS FUTILE. DO NOT EDIT.
//
// Generated by pipeline:
//     terraform
// Using jennies:
//     TerraformDataSourceJenny
//     ComposableLatestMajorsOrXJenny
//
// Run 'go generate ./' from repository root to regenerate.

package provider

import (
	"context"
	"encoding/json"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure that the imports are used to avoid compiler errors.
var _ attr.Value
var _ diag.Diagnostic

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ datasource.DataSource              = &PanelGeomapDataSource{}
	_ datasource.DataSourceWithConfigure = &PanelGeomapDataSource{}
)

func NewPanelGeomapDataSource() datasource.DataSource {
	return &PanelGeomapDataSource{}
}

// PanelGeomapDataSource defines the data source implementation.
type PanelGeomapDataSource struct{}

type PanelGeomapDataSourceModel_Datasource struct {
	Type types.String `tfsdk:"type"`
	Uid  types.String `tfsdk:"uid"`
}

func (m PanelGeomapDataSourceModel_Datasource) MarshalJSON() ([]byte, error) {
	type jsonPanelGeomapDataSourceModel_Datasource struct {
		Type *string `json:"type,omitempty"`
		Uid  *string `json:"uid,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_type := m.Type.ValueString()
	attr_uid := m.Uid.ValueString()

	model := &jsonPanelGeomapDataSourceModel_Datasource{
		Type: &attr_type,
		Uid:  &attr_uid,
	}
	return json.Marshal(model)
}

func (m PanelGeomapDataSourceModel_Datasource) ApplyDefaults() PanelGeomapDataSourceModel_Datasource {

	return m
}

type PanelGeomapDataSourceModel_GridPos struct {
	H      types.Int64 `tfsdk:"h"`
	W      types.Int64 `tfsdk:"w"`
	X      types.Int64 `tfsdk:"x"`
	Y      types.Int64 `tfsdk:"y"`
	Static types.Bool  `tfsdk:"static"`
}

func (m PanelGeomapDataSourceModel_GridPos) MarshalJSON() ([]byte, error) {
	type jsonPanelGeomapDataSourceModel_GridPos struct {
		H      int64 `json:"h"`
		W      int64 `json:"w"`
		X      int64 `json:"x"`
		Y      int64 `json:"y"`
		Static *bool `json:"static,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_h := m.H.ValueInt64()
	attr_w := m.W.ValueInt64()
	attr_x := m.X.ValueInt64()
	attr_y := m.Y.ValueInt64()
	attr_static := m.Static.ValueBool()

	model := &jsonPanelGeomapDataSourceModel_GridPos{
		H:      attr_h,
		W:      attr_w,
		X:      attr_x,
		Y:      attr_y,
		Static: &attr_static,
	}
	return json.Marshal(model)
}

func (m PanelGeomapDataSourceModel_GridPos) ApplyDefaults() PanelGeomapDataSourceModel_GridPos {
	if m.H.IsNull() {
		m.H = types.Int64Value(9)
	}
	if m.W.IsNull() {
		m.W = types.Int64Value(12)
	}
	if m.X.IsNull() {
		m.X = types.Int64Value(0)
	}
	if m.Y.IsNull() {
		m.Y = types.Int64Value(0)
	}
	return m
}

type PanelGeomapDataSourceModel_Links struct {
	Title       types.String `tfsdk:"title"`
	Type        types.String `tfsdk:"type"`
	Icon        types.String `tfsdk:"icon"`
	Tooltip     types.String `tfsdk:"tooltip"`
	Url         types.String `tfsdk:"url"`
	Tags        types.List   `tfsdk:"tags"`
	AsDropdown  types.Bool   `tfsdk:"as_dropdown"`
	TargetBlank types.Bool   `tfsdk:"target_blank"`
	IncludeVars types.Bool   `tfsdk:"include_vars"`
	KeepTime    types.Bool   `tfsdk:"keep_time"`
}

func (m PanelGeomapDataSourceModel_Links) MarshalJSON() ([]byte, error) {
	type jsonPanelGeomapDataSourceModel_Links struct {
		Title       string   `json:"title"`
		Type        string   `json:"type"`
		Icon        string   `json:"icon"`
		Tooltip     string   `json:"tooltip"`
		Url         string   `json:"url"`
		Tags        []string `json:"tags,omitempty"`
		AsDropdown  bool     `json:"asDropdown"`
		TargetBlank bool     `json:"targetBlank"`
		IncludeVars bool     `json:"includeVars"`
		KeepTime    bool     `json:"keepTime"`
	}

	m = m.ApplyDefaults()
	attr_title := m.Title.ValueString()
	attr_type := m.Type.ValueString()
	attr_icon := m.Icon.ValueString()
	attr_tooltip := m.Tooltip.ValueString()
	attr_url := m.Url.ValueString()
	attr_tags := []string{}
	for _, v := range m.Tags.Elements() {
		attr_tags = append(attr_tags, v.(types.String).ValueString())
	}
	attr_asdropdown := m.AsDropdown.ValueBool()
	attr_targetblank := m.TargetBlank.ValueBool()
	attr_includevars := m.IncludeVars.ValueBool()
	attr_keeptime := m.KeepTime.ValueBool()

	model := &jsonPanelGeomapDataSourceModel_Links{
		Title:       attr_title,
		Type:        attr_type,
		Icon:        attr_icon,
		Tooltip:     attr_tooltip,
		Url:         attr_url,
		Tags:        attr_tags,
		AsDropdown:  attr_asdropdown,
		TargetBlank: attr_targetblank,
		IncludeVars: attr_includevars,
		KeepTime:    attr_keeptime,
	}
	return json.Marshal(model)
}

func (m PanelGeomapDataSourceModel_Links) ApplyDefaults() PanelGeomapDataSourceModel_Links {
	if len(m.Tags.Elements()) == 0 {
		m.Tags, _ = types.ListValue(types.StringType, []attr.Value{})
	}
	if m.AsDropdown.IsNull() {
		m.AsDropdown = types.BoolValue(false)
	}
	if m.TargetBlank.IsNull() {
		m.TargetBlank = types.BoolValue(false)
	}
	if m.IncludeVars.IsNull() {
		m.IncludeVars = types.BoolValue(false)
	}
	if m.KeepTime.IsNull() {
		m.KeepTime = types.BoolValue(false)
	}
	return m
}

type PanelGeomapDataSourceModel_Transformations_Filter struct {
}

func (m PanelGeomapDataSourceModel_Transformations_Filter) MarshalJSON() ([]byte, error) {
	type jsonPanelGeomapDataSourceModel_Transformations_Filter struct {
	}

	m = m.ApplyDefaults()

	model := &jsonPanelGeomapDataSourceModel_Transformations_Filter{}
	return json.Marshal(model)
}

func (m PanelGeomapDataSourceModel_Transformations_Filter) ApplyDefaults() PanelGeomapDataSourceModel_Transformations_Filter {

	return m
}

type PanelGeomapDataSourceModel_Transformations struct {
	Disabled types.Bool                                         `tfsdk:"disabled"`
	Filter   *PanelGeomapDataSourceModel_Transformations_Filter `tfsdk:"filter"`
}

func (m PanelGeomapDataSourceModel_Transformations) MarshalJSON() ([]byte, error) {
	type jsonPanelGeomapDataSourceModel_Transformations struct {
		Disabled *bool       `json:"disabled,omitempty"`
		Filter   interface{} `json:"filter,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_disabled := m.Disabled.ValueBool()
	var attr_filter interface{}
	if m.Filter != nil {
		attr_filter = m.Filter
	}

	model := &jsonPanelGeomapDataSourceModel_Transformations{
		Disabled: &attr_disabled,
		Filter:   attr_filter,
	}
	return json.Marshal(model)
}

func (m PanelGeomapDataSourceModel_Transformations) ApplyDefaults() PanelGeomapDataSourceModel_Transformations {

	return m
}

type PanelGeomapDataSourceModel_LibraryPanel struct {
	Name types.String `tfsdk:"name"`
	Uid  types.String `tfsdk:"uid"`
}

func (m PanelGeomapDataSourceModel_LibraryPanel) MarshalJSON() ([]byte, error) {
	type jsonPanelGeomapDataSourceModel_LibraryPanel struct {
		Name string `json:"name"`
		Uid  string `json:"uid"`
	}

	m = m.ApplyDefaults()
	attr_name := m.Name.ValueString()
	attr_uid := m.Uid.ValueString()

	model := &jsonPanelGeomapDataSourceModel_LibraryPanel{
		Name: attr_name,
		Uid:  attr_uid,
	}
	return json.Marshal(model)
}

func (m PanelGeomapDataSourceModel_LibraryPanel) ApplyDefaults() PanelGeomapDataSourceModel_LibraryPanel {

	return m
}

type PanelGeomapDataSourceModel_Options_View struct {
	Lat       types.Int64  `tfsdk:"lat"`
	Lon       types.Int64  `tfsdk:"lon"`
	Zoom      types.Int64  `tfsdk:"zoom"`
	MinZoom   types.Int64  `tfsdk:"min_zoom"`
	MaxZoom   types.Int64  `tfsdk:"max_zoom"`
	Padding   types.Int64  `tfsdk:"padding"`
	AllLayers types.Bool   `tfsdk:"all_layers"`
	LastOnly  types.Bool   `tfsdk:"last_only"`
	Layer     types.String `tfsdk:"layer"`
	Shared    types.Bool   `tfsdk:"shared"`
}

func (m PanelGeomapDataSourceModel_Options_View) MarshalJSON() ([]byte, error) {
	type jsonPanelGeomapDataSourceModel_Options_View struct {
		Lat       *int64  `json:"lat,omitempty"`
		Lon       *int64  `json:"lon,omitempty"`
		Zoom      *int64  `json:"zoom,omitempty"`
		MinZoom   *int64  `json:"minZoom,omitempty"`
		MaxZoom   *int64  `json:"maxZoom,omitempty"`
		Padding   *int64  `json:"padding,omitempty"`
		AllLayers *bool   `json:"allLayers,omitempty"`
		LastOnly  *bool   `json:"lastOnly,omitempty"`
		Layer     *string `json:"layer,omitempty"`
		Shared    *bool   `json:"shared,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_lat := m.Lat.ValueInt64()
	attr_lon := m.Lon.ValueInt64()
	attr_zoom := m.Zoom.ValueInt64()
	attr_minzoom := m.MinZoom.ValueInt64()
	attr_maxzoom := m.MaxZoom.ValueInt64()
	attr_padding := m.Padding.ValueInt64()
	attr_alllayers := m.AllLayers.ValueBool()
	attr_lastonly := m.LastOnly.ValueBool()
	attr_layer := m.Layer.ValueString()
	attr_shared := m.Shared.ValueBool()

	model := &jsonPanelGeomapDataSourceModel_Options_View{
		Lat:       &attr_lat,
		Lon:       &attr_lon,
		Zoom:      &attr_zoom,
		MinZoom:   &attr_minzoom,
		MaxZoom:   &attr_maxzoom,
		Padding:   &attr_padding,
		AllLayers: &attr_alllayers,
		LastOnly:  &attr_lastonly,
		Layer:     &attr_layer,
		Shared:    &attr_shared,
	}
	return json.Marshal(model)
}

func (m PanelGeomapDataSourceModel_Options_View) ApplyDefaults() PanelGeomapDataSourceModel_Options_View {
	if m.Lat.IsNull() {
		m.Lat = types.Int64Value(0)
	}
	if m.Lon.IsNull() {
		m.Lon = types.Int64Value(0)
	}
	if m.Zoom.IsNull() {
		m.Zoom = types.Int64Value(1)
	}
	if m.AllLayers.IsNull() {
		m.AllLayers = types.BoolValue(true)
	}
	return m
}

type PanelGeomapDataSourceModel_Options_Controls struct {
	ShowZoom        types.Bool `tfsdk:"show_zoom"`
	MouseWheelZoom  types.Bool `tfsdk:"mouse_wheel_zoom"`
	ShowAttribution types.Bool `tfsdk:"show_attribution"`
	ShowScale       types.Bool `tfsdk:"show_scale"`
	ShowDebug       types.Bool `tfsdk:"show_debug"`
	ShowMeasure     types.Bool `tfsdk:"show_measure"`
}

func (m PanelGeomapDataSourceModel_Options_Controls) MarshalJSON() ([]byte, error) {
	type jsonPanelGeomapDataSourceModel_Options_Controls struct {
		ShowZoom        *bool `json:"showZoom,omitempty"`
		MouseWheelZoom  *bool `json:"mouseWheelZoom,omitempty"`
		ShowAttribution *bool `json:"showAttribution,omitempty"`
		ShowScale       *bool `json:"showScale,omitempty"`
		ShowDebug       *bool `json:"showDebug,omitempty"`
		ShowMeasure     *bool `json:"showMeasure,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_showzoom := m.ShowZoom.ValueBool()
	attr_mousewheelzoom := m.MouseWheelZoom.ValueBool()
	attr_showattribution := m.ShowAttribution.ValueBool()
	attr_showscale := m.ShowScale.ValueBool()
	attr_showdebug := m.ShowDebug.ValueBool()
	attr_showmeasure := m.ShowMeasure.ValueBool()

	model := &jsonPanelGeomapDataSourceModel_Options_Controls{
		ShowZoom:        &attr_showzoom,
		MouseWheelZoom:  &attr_mousewheelzoom,
		ShowAttribution: &attr_showattribution,
		ShowScale:       &attr_showscale,
		ShowDebug:       &attr_showdebug,
		ShowMeasure:     &attr_showmeasure,
	}
	return json.Marshal(model)
}

func (m PanelGeomapDataSourceModel_Options_Controls) ApplyDefaults() PanelGeomapDataSourceModel_Options_Controls {

	return m
}

type PanelGeomapDataSourceModel_Options_Basemap_Location struct {
	Mode      types.String `tfsdk:"mode"`
	Geohash   types.String `tfsdk:"geohash"`
	Latitude  types.String `tfsdk:"latitude"`
	Longitude types.String `tfsdk:"longitude"`
	Wkt       types.String `tfsdk:"wkt"`
	Lookup    types.String `tfsdk:"lookup"`
	Gazetteer types.String `tfsdk:"gazetteer"`
}

func (m PanelGeomapDataSourceModel_Options_Basemap_Location) MarshalJSON() ([]byte, error) {
	type jsonPanelGeomapDataSourceModel_Options_Basemap_Location struct {
		Mode      string  `json:"mode"`
		Geohash   *string `json:"geohash,omitempty"`
		Latitude  *string `json:"latitude,omitempty"`
		Longitude *string `json:"longitude,omitempty"`
		Wkt       *string `json:"wkt,omitempty"`
		Lookup    *string `json:"lookup,omitempty"`
		Gazetteer *string `json:"gazetteer,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_mode := m.Mode.ValueString()
	attr_geohash := m.Geohash.ValueString()
	attr_latitude := m.Latitude.ValueString()
	attr_longitude := m.Longitude.ValueString()
	attr_wkt := m.Wkt.ValueString()
	attr_lookup := m.Lookup.ValueString()
	attr_gazetteer := m.Gazetteer.ValueString()

	model := &jsonPanelGeomapDataSourceModel_Options_Basemap_Location{
		Mode:      attr_mode,
		Geohash:   &attr_geohash,
		Latitude:  &attr_latitude,
		Longitude: &attr_longitude,
		Wkt:       &attr_wkt,
		Lookup:    &attr_lookup,
		Gazetteer: &attr_gazetteer,
	}
	return json.Marshal(model)
}

func (m PanelGeomapDataSourceModel_Options_Basemap_Location) ApplyDefaults() PanelGeomapDataSourceModel_Options_Basemap_Location {

	return m
}

type PanelGeomapDataSourceModel_Options_Basemap struct {
	Type     types.String                                         `tfsdk:"type"`
	Name     types.String                                         `tfsdk:"name"`
	Location *PanelGeomapDataSourceModel_Options_Basemap_Location `tfsdk:"location"`
	Opacity  types.Int64                                          `tfsdk:"opacity"`
	Tooltip  types.Bool                                           `tfsdk:"tooltip"`
}

func (m PanelGeomapDataSourceModel_Options_Basemap) MarshalJSON() ([]byte, error) {
	type jsonPanelGeomapDataSourceModel_Options_Basemap struct {
		Type     string      `json:"type"`
		Name     string      `json:"name"`
		Location interface{} `json:"location,omitempty"`
		Opacity  *int64      `json:"opacity,omitempty"`
		Tooltip  *bool       `json:"tooltip,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_type := m.Type.ValueString()
	attr_name := m.Name.ValueString()
	var attr_location interface{}
	if m.Location != nil {
		attr_location = m.Location
	}
	attr_opacity := m.Opacity.ValueInt64()
	attr_tooltip := m.Tooltip.ValueBool()

	model := &jsonPanelGeomapDataSourceModel_Options_Basemap{
		Type:     attr_type,
		Name:     attr_name,
		Location: attr_location,
		Opacity:  &attr_opacity,
		Tooltip:  &attr_tooltip,
	}
	return json.Marshal(model)
}

func (m PanelGeomapDataSourceModel_Options_Basemap) ApplyDefaults() PanelGeomapDataSourceModel_Options_Basemap {

	return m
}

type PanelGeomapDataSourceModel_Options_Layers_Location struct {
	Mode      types.String `tfsdk:"mode"`
	Geohash   types.String `tfsdk:"geohash"`
	Latitude  types.String `tfsdk:"latitude"`
	Longitude types.String `tfsdk:"longitude"`
	Wkt       types.String `tfsdk:"wkt"`
	Lookup    types.String `tfsdk:"lookup"`
	Gazetteer types.String `tfsdk:"gazetteer"`
}

func (m PanelGeomapDataSourceModel_Options_Layers_Location) MarshalJSON() ([]byte, error) {
	type jsonPanelGeomapDataSourceModel_Options_Layers_Location struct {
		Mode      string  `json:"mode"`
		Geohash   *string `json:"geohash,omitempty"`
		Latitude  *string `json:"latitude,omitempty"`
		Longitude *string `json:"longitude,omitempty"`
		Wkt       *string `json:"wkt,omitempty"`
		Lookup    *string `json:"lookup,omitempty"`
		Gazetteer *string `json:"gazetteer,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_mode := m.Mode.ValueString()
	attr_geohash := m.Geohash.ValueString()
	attr_latitude := m.Latitude.ValueString()
	attr_longitude := m.Longitude.ValueString()
	attr_wkt := m.Wkt.ValueString()
	attr_lookup := m.Lookup.ValueString()
	attr_gazetteer := m.Gazetteer.ValueString()

	model := &jsonPanelGeomapDataSourceModel_Options_Layers_Location{
		Mode:      attr_mode,
		Geohash:   &attr_geohash,
		Latitude:  &attr_latitude,
		Longitude: &attr_longitude,
		Wkt:       &attr_wkt,
		Lookup:    &attr_lookup,
		Gazetteer: &attr_gazetteer,
	}
	return json.Marshal(model)
}

func (m PanelGeomapDataSourceModel_Options_Layers_Location) ApplyDefaults() PanelGeomapDataSourceModel_Options_Layers_Location {

	return m
}

type PanelGeomapDataSourceModel_Options_Layers struct {
	Type     types.String                                        `tfsdk:"type"`
	Name     types.String                                        `tfsdk:"name"`
	Location *PanelGeomapDataSourceModel_Options_Layers_Location `tfsdk:"location"`
	Opacity  types.Int64                                         `tfsdk:"opacity"`
	Tooltip  types.Bool                                          `tfsdk:"tooltip"`
}

func (m PanelGeomapDataSourceModel_Options_Layers) MarshalJSON() ([]byte, error) {
	type jsonPanelGeomapDataSourceModel_Options_Layers struct {
		Type     string      `json:"type"`
		Name     string      `json:"name"`
		Location interface{} `json:"location,omitempty"`
		Opacity  *int64      `json:"opacity,omitempty"`
		Tooltip  *bool       `json:"tooltip,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_type := m.Type.ValueString()
	attr_name := m.Name.ValueString()
	var attr_location interface{}
	if m.Location != nil {
		attr_location = m.Location
	}
	attr_opacity := m.Opacity.ValueInt64()
	attr_tooltip := m.Tooltip.ValueBool()

	model := &jsonPanelGeomapDataSourceModel_Options_Layers{
		Type:     attr_type,
		Name:     attr_name,
		Location: attr_location,
		Opacity:  &attr_opacity,
		Tooltip:  &attr_tooltip,
	}
	return json.Marshal(model)
}

func (m PanelGeomapDataSourceModel_Options_Layers) ApplyDefaults() PanelGeomapDataSourceModel_Options_Layers {

	return m
}

type PanelGeomapDataSourceModel_Options_Tooltip struct {
	Mode types.String `tfsdk:"mode"`
}

func (m PanelGeomapDataSourceModel_Options_Tooltip) MarshalJSON() ([]byte, error) {
	type jsonPanelGeomapDataSourceModel_Options_Tooltip struct {
		Mode string `json:"mode"`
	}

	m = m.ApplyDefaults()
	attr_mode := m.Mode.ValueString()

	model := &jsonPanelGeomapDataSourceModel_Options_Tooltip{
		Mode: attr_mode,
	}
	return json.Marshal(model)
}

func (m PanelGeomapDataSourceModel_Options_Tooltip) ApplyDefaults() PanelGeomapDataSourceModel_Options_Tooltip {

	return m
}

type PanelGeomapDataSourceModel_Options struct {
	View     *PanelGeomapDataSourceModel_Options_View     `tfsdk:"view"`
	Controls *PanelGeomapDataSourceModel_Options_Controls `tfsdk:"controls"`
	Basemap  *PanelGeomapDataSourceModel_Options_Basemap  `tfsdk:"basemap"`
	Layers   []PanelGeomapDataSourceModel_Options_Layers  `tfsdk:"layers"`
	Tooltip  *PanelGeomapDataSourceModel_Options_Tooltip  `tfsdk:"tooltip"`
}

func (m PanelGeomapDataSourceModel_Options) MarshalJSON() ([]byte, error) {
	type jsonPanelGeomapDataSourceModel_Options struct {
		View     interface{}   `json:"view,omitempty"`
		Controls interface{}   `json:"controls,omitempty"`
		Basemap  interface{}   `json:"basemap,omitempty"`
		Layers   []interface{} `json:"layers,omitempty"`
		Tooltip  interface{}   `json:"tooltip,omitempty"`
	}

	m = m.ApplyDefaults()
	var attr_view interface{}
	if m.View != nil {
		attr_view = m.View
	}
	var attr_controls interface{}
	if m.Controls != nil {
		attr_controls = m.Controls
	}
	var attr_basemap interface{}
	if m.Basemap != nil {
		attr_basemap = m.Basemap
	}
	attr_layers := []interface{}{}
	for _, v := range m.Layers {
		attr_layers = append(attr_layers, v)
	}
	var attr_tooltip interface{}
	if m.Tooltip != nil {
		attr_tooltip = m.Tooltip
	}

	model := &jsonPanelGeomapDataSourceModel_Options{
		View:     attr_view,
		Controls: attr_controls,
		Basemap:  attr_basemap,
		Layers:   attr_layers,
		Tooltip:  attr_tooltip,
	}
	return json.Marshal(model)
}

func (m PanelGeomapDataSourceModel_Options) ApplyDefaults() PanelGeomapDataSourceModel_Options {

	return m
}

type PanelGeomapDataSourceModel_FieldConfig_Defaults_Thresholds_Steps struct {
	Value types.Float64 `tfsdk:"value"`
	Color types.String  `tfsdk:"color"`
	State types.String  `tfsdk:"state"`
}

func (m PanelGeomapDataSourceModel_FieldConfig_Defaults_Thresholds_Steps) MarshalJSON() ([]byte, error) {
	type jsonPanelGeomapDataSourceModel_FieldConfig_Defaults_Thresholds_Steps struct {
		Value *float64 `json:"value,omitempty"`
		Color string   `json:"color"`
		State *string  `json:"state,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_value := m.Value.ValueFloat64()
	attr_color := m.Color.ValueString()
	attr_state := m.State.ValueString()

	model := &jsonPanelGeomapDataSourceModel_FieldConfig_Defaults_Thresholds_Steps{
		Value: &attr_value,
		Color: attr_color,
		State: &attr_state,
	}
	return json.Marshal(model)
}

func (m PanelGeomapDataSourceModel_FieldConfig_Defaults_Thresholds_Steps) ApplyDefaults() PanelGeomapDataSourceModel_FieldConfig_Defaults_Thresholds_Steps {

	return m
}

type PanelGeomapDataSourceModel_FieldConfig_Defaults_Thresholds struct {
	Mode  types.String                                                       `tfsdk:"mode"`
	Steps []PanelGeomapDataSourceModel_FieldConfig_Defaults_Thresholds_Steps `tfsdk:"steps"`
}

func (m PanelGeomapDataSourceModel_FieldConfig_Defaults_Thresholds) MarshalJSON() ([]byte, error) {
	type jsonPanelGeomapDataSourceModel_FieldConfig_Defaults_Thresholds struct {
		Mode  string        `json:"mode"`
		Steps []interface{} `json:"steps,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_mode := m.Mode.ValueString()
	attr_steps := []interface{}{}
	for _, v := range m.Steps {
		attr_steps = append(attr_steps, v)
	}

	model := &jsonPanelGeomapDataSourceModel_FieldConfig_Defaults_Thresholds{
		Mode:  attr_mode,
		Steps: attr_steps,
	}
	return json.Marshal(model)
}

func (m PanelGeomapDataSourceModel_FieldConfig_Defaults_Thresholds) ApplyDefaults() PanelGeomapDataSourceModel_FieldConfig_Defaults_Thresholds {

	return m
}

type PanelGeomapDataSourceModel_FieldConfig_Defaults_Color struct {
	Mode       types.String `tfsdk:"mode"`
	FixedColor types.String `tfsdk:"fixed_color"`
	SeriesBy   types.String `tfsdk:"series_by"`
}

func (m PanelGeomapDataSourceModel_FieldConfig_Defaults_Color) MarshalJSON() ([]byte, error) {
	type jsonPanelGeomapDataSourceModel_FieldConfig_Defaults_Color struct {
		Mode       string  `json:"mode"`
		FixedColor *string `json:"fixedColor,omitempty"`
		SeriesBy   *string `json:"seriesBy,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_mode := m.Mode.ValueString()
	attr_fixedcolor := m.FixedColor.ValueString()
	attr_seriesby := m.SeriesBy.ValueString()

	model := &jsonPanelGeomapDataSourceModel_FieldConfig_Defaults_Color{
		Mode:       attr_mode,
		FixedColor: &attr_fixedcolor,
		SeriesBy:   &attr_seriesby,
	}
	return json.Marshal(model)
}

func (m PanelGeomapDataSourceModel_FieldConfig_Defaults_Color) ApplyDefaults() PanelGeomapDataSourceModel_FieldConfig_Defaults_Color {

	return m
}

type PanelGeomapDataSourceModel_FieldConfig_Defaults_Custom struct {
}

func (m PanelGeomapDataSourceModel_FieldConfig_Defaults_Custom) MarshalJSON() ([]byte, error) {
	type jsonPanelGeomapDataSourceModel_FieldConfig_Defaults_Custom struct {
	}

	m = m.ApplyDefaults()

	model := &jsonPanelGeomapDataSourceModel_FieldConfig_Defaults_Custom{}
	return json.Marshal(model)
}

func (m PanelGeomapDataSourceModel_FieldConfig_Defaults_Custom) ApplyDefaults() PanelGeomapDataSourceModel_FieldConfig_Defaults_Custom {

	return m
}

type PanelGeomapDataSourceModel_FieldConfig_Defaults struct {
	DisplayName       types.String                                                `tfsdk:"display_name"`
	DisplayNameFromDS types.String                                                `tfsdk:"display_name_from_ds"`
	Description       types.String                                                `tfsdk:"description"`
	Path              types.String                                                `tfsdk:"path"`
	Writeable         types.Bool                                                  `tfsdk:"writeable"`
	Filterable        types.Bool                                                  `tfsdk:"filterable"`
	Unit              types.String                                                `tfsdk:"unit"`
	Decimals          types.Float64                                               `tfsdk:"decimals"`
	Min               types.Float64                                               `tfsdk:"min"`
	Max               types.Float64                                               `tfsdk:"max"`
	Thresholds        *PanelGeomapDataSourceModel_FieldConfig_Defaults_Thresholds `tfsdk:"thresholds"`
	Color             *PanelGeomapDataSourceModel_FieldConfig_Defaults_Color      `tfsdk:"color"`
	NoValue           types.String                                                `tfsdk:"no_value"`
	Custom            *PanelGeomapDataSourceModel_FieldConfig_Defaults_Custom     `tfsdk:"custom"`
}

func (m PanelGeomapDataSourceModel_FieldConfig_Defaults) MarshalJSON() ([]byte, error) {
	type jsonPanelGeomapDataSourceModel_FieldConfig_Defaults struct {
		DisplayName       *string     `json:"displayName,omitempty"`
		DisplayNameFromDS *string     `json:"displayNameFromDS,omitempty"`
		Description       *string     `json:"description,omitempty"`
		Path              *string     `json:"path,omitempty"`
		Writeable         *bool       `json:"writeable,omitempty"`
		Filterable        *bool       `json:"filterable,omitempty"`
		Unit              *string     `json:"unit,omitempty"`
		Decimals          *float64    `json:"decimals,omitempty"`
		Min               *float64    `json:"min,omitempty"`
		Max               *float64    `json:"max,omitempty"`
		Thresholds        interface{} `json:"thresholds,omitempty"`
		Color             interface{} `json:"color,omitempty"`
		NoValue           *string     `json:"noValue,omitempty"`
		Custom            interface{} `json:"custom,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_displayname := m.DisplayName.ValueString()
	attr_displaynamefromds := m.DisplayNameFromDS.ValueString()
	attr_description := m.Description.ValueString()
	attr_path := m.Path.ValueString()
	attr_writeable := m.Writeable.ValueBool()
	attr_filterable := m.Filterable.ValueBool()
	attr_unit := m.Unit.ValueString()
	attr_decimals := m.Decimals.ValueFloat64()
	attr_min := m.Min.ValueFloat64()
	attr_max := m.Max.ValueFloat64()
	var attr_thresholds interface{}
	if m.Thresholds != nil {
		attr_thresholds = m.Thresholds
	}
	var attr_color interface{}
	if m.Color != nil {
		attr_color = m.Color
	}
	attr_novalue := m.NoValue.ValueString()
	var attr_custom interface{}
	if m.Custom != nil {
		attr_custom = m.Custom
	}

	model := &jsonPanelGeomapDataSourceModel_FieldConfig_Defaults{
		DisplayName:       &attr_displayname,
		DisplayNameFromDS: &attr_displaynamefromds,
		Description:       &attr_description,
		Path:              &attr_path,
		Writeable:         &attr_writeable,
		Filterable:        &attr_filterable,
		Unit:              &attr_unit,
		Decimals:          &attr_decimals,
		Min:               &attr_min,
		Max:               &attr_max,
		Thresholds:        attr_thresholds,
		Color:             attr_color,
		NoValue:           &attr_novalue,
		Custom:            attr_custom,
	}
	return json.Marshal(model)
}

func (m PanelGeomapDataSourceModel_FieldConfig_Defaults) ApplyDefaults() PanelGeomapDataSourceModel_FieldConfig_Defaults {

	return m
}

type PanelGeomapDataSourceModel_FieldConfig_Overrides_Matcher struct {
}

func (m PanelGeomapDataSourceModel_FieldConfig_Overrides_Matcher) MarshalJSON() ([]byte, error) {
	type jsonPanelGeomapDataSourceModel_FieldConfig_Overrides_Matcher struct {
	}

	m = m.ApplyDefaults()

	model := &jsonPanelGeomapDataSourceModel_FieldConfig_Overrides_Matcher{}
	return json.Marshal(model)
}

func (m PanelGeomapDataSourceModel_FieldConfig_Overrides_Matcher) ApplyDefaults() PanelGeomapDataSourceModel_FieldConfig_Overrides_Matcher {

	return m
}

type PanelGeomapDataSourceModel_FieldConfig_Overrides_Properties struct {
}

func (m PanelGeomapDataSourceModel_FieldConfig_Overrides_Properties) MarshalJSON() ([]byte, error) {
	type jsonPanelGeomapDataSourceModel_FieldConfig_Overrides_Properties struct {
	}

	m = m.ApplyDefaults()

	model := &jsonPanelGeomapDataSourceModel_FieldConfig_Overrides_Properties{}
	return json.Marshal(model)
}

func (m PanelGeomapDataSourceModel_FieldConfig_Overrides_Properties) ApplyDefaults() PanelGeomapDataSourceModel_FieldConfig_Overrides_Properties {

	return m
}

type PanelGeomapDataSourceModel_FieldConfig_Overrides struct {
	Matcher    *PanelGeomapDataSourceModel_FieldConfig_Overrides_Matcher     `tfsdk:"matcher"`
	Properties []PanelGeomapDataSourceModel_FieldConfig_Overrides_Properties `tfsdk:"properties"`
}

func (m PanelGeomapDataSourceModel_FieldConfig_Overrides) MarshalJSON() ([]byte, error) {
	type jsonPanelGeomapDataSourceModel_FieldConfig_Overrides struct {
		Matcher    interface{}   `json:"matcher,omitempty"`
		Properties []interface{} `json:"properties,omitempty"`
	}

	m = m.ApplyDefaults()
	var attr_matcher interface{}
	if m.Matcher != nil {
		attr_matcher = m.Matcher
	}
	attr_properties := []interface{}{}
	for _, v := range m.Properties {
		attr_properties = append(attr_properties, v)
	}

	model := &jsonPanelGeomapDataSourceModel_FieldConfig_Overrides{
		Matcher:    attr_matcher,
		Properties: attr_properties,
	}
	return json.Marshal(model)
}

func (m PanelGeomapDataSourceModel_FieldConfig_Overrides) ApplyDefaults() PanelGeomapDataSourceModel_FieldConfig_Overrides {

	return m
}

type PanelGeomapDataSourceModel_FieldConfig struct {
	Defaults  *PanelGeomapDataSourceModel_FieldConfig_Defaults   `tfsdk:"defaults"`
	Overrides []PanelGeomapDataSourceModel_FieldConfig_Overrides `tfsdk:"overrides"`
}

func (m PanelGeomapDataSourceModel_FieldConfig) MarshalJSON() ([]byte, error) {
	type jsonPanelGeomapDataSourceModel_FieldConfig struct {
		Defaults  interface{}   `json:"defaults,omitempty"`
		Overrides []interface{} `json:"overrides,omitempty"`
	}

	m = m.ApplyDefaults()
	var attr_defaults interface{}
	if m.Defaults != nil {
		attr_defaults = m.Defaults
	}
	attr_overrides := []interface{}{}
	for _, v := range m.Overrides {
		attr_overrides = append(attr_overrides, v)
	}

	model := &jsonPanelGeomapDataSourceModel_FieldConfig{
		Defaults:  attr_defaults,
		Overrides: attr_overrides,
	}
	return json.Marshal(model)
}

func (m PanelGeomapDataSourceModel_FieldConfig) ApplyDefaults() PanelGeomapDataSourceModel_FieldConfig {

	return m
}

type PanelGeomapDataSourceModel struct {
	ToJSON          types.String                                 `tfsdk:"to_json"`
	Type            types.String                                 `tfsdk:"type"`
	PluginVersion   types.String                                 `tfsdk:"plugin_version"`
	Tags            types.List                                   `tfsdk:"tags"`
	Targets         types.List                                   `tfsdk:"targets"`
	Title           types.String                                 `tfsdk:"title"`
	Description     types.String                                 `tfsdk:"description"`
	Transparent     types.Bool                                   `tfsdk:"transparent"`
	Datasource      *PanelGeomapDataSourceModel_Datasource       `tfsdk:"datasource"`
	GridPos         *PanelGeomapDataSourceModel_GridPos          `tfsdk:"grid_pos"`
	Links           []PanelGeomapDataSourceModel_Links           `tfsdk:"links"`
	Repeat          types.String                                 `tfsdk:"repeat"`
	RepeatDirection types.String                                 `tfsdk:"repeat_direction"`
	RepeatPanelId   types.Int64                                  `tfsdk:"repeat_panel_id"`
	MaxDataPoints   types.Float64                                `tfsdk:"max_data_points"`
	Transformations []PanelGeomapDataSourceModel_Transformations `tfsdk:"transformations"`
	Interval        types.String                                 `tfsdk:"interval"`
	TimeFrom        types.String                                 `tfsdk:"time_from"`
	TimeShift       types.String                                 `tfsdk:"time_shift"`
	LibraryPanel    *PanelGeomapDataSourceModel_LibraryPanel     `tfsdk:"library_panel"`
	Options         *PanelGeomapDataSourceModel_Options          `tfsdk:"options"`
	FieldConfig     *PanelGeomapDataSourceModel_FieldConfig      `tfsdk:"field_config"`
}

func (m PanelGeomapDataSourceModel) MarshalJSON() ([]byte, error) {
	type jsonPanelGeomapDataSourceModel struct {
		Type            string        `json:"type"`
		PluginVersion   *string       `json:"pluginVersion,omitempty"`
		Tags            []string      `json:"tags,omitempty"`
		Targets         []string      `json:"targets,omitempty"`
		Title           *string       `json:"title,omitempty"`
		Description     *string       `json:"description,omitempty"`
		Transparent     bool          `json:"transparent"`
		Datasource      interface{}   `json:"datasource,omitempty"`
		GridPos         interface{}   `json:"gridPos,omitempty"`
		Links           []interface{} `json:"links,omitempty"`
		Repeat          *string       `json:"repeat,omitempty"`
		RepeatDirection string        `json:"repeatDirection"`
		RepeatPanelId   *int64        `json:"repeatPanelId,omitempty"`
		MaxDataPoints   *float64      `json:"maxDataPoints,omitempty"`
		Transformations []interface{} `json:"transformations,omitempty"`
		Interval        *string       `json:"interval,omitempty"`
		TimeFrom        *string       `json:"timeFrom,omitempty"`
		TimeShift       *string       `json:"timeShift,omitempty"`
		LibraryPanel    interface{}   `json:"libraryPanel,omitempty"`
		Options         interface{}   `json:"options,omitempty"`
		FieldConfig     interface{}   `json:"fieldConfig,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_type := m.Type.ValueString()
	attr_pluginversion := m.PluginVersion.ValueString()
	attr_tags := []string{}
	for _, v := range m.Tags.Elements() {
		attr_tags = append(attr_tags, v.(types.String).ValueString())
	}
	attr_targets := []string{}
	for _, v := range m.Targets.Elements() {
		attr_targets = append(attr_targets, v.(types.String).ValueString())
	}
	attr_title := m.Title.ValueString()
	attr_description := m.Description.ValueString()
	attr_transparent := m.Transparent.ValueBool()
	var attr_datasource interface{}
	if m.Datasource != nil {
		attr_datasource = m.Datasource
	}
	var attr_gridpos interface{}
	if m.GridPos != nil {
		attr_gridpos = m.GridPos
	}
	attr_links := []interface{}{}
	for _, v := range m.Links {
		attr_links = append(attr_links, v)
	}
	attr_repeat := m.Repeat.ValueString()
	attr_repeatdirection := m.RepeatDirection.ValueString()
	attr_repeatpanelid := m.RepeatPanelId.ValueInt64()
	attr_maxdatapoints := m.MaxDataPoints.ValueFloat64()
	attr_transformations := []interface{}{}
	for _, v := range m.Transformations {
		attr_transformations = append(attr_transformations, v)
	}
	attr_interval := m.Interval.ValueString()
	attr_timefrom := m.TimeFrom.ValueString()
	attr_timeshift := m.TimeShift.ValueString()
	var attr_librarypanel interface{}
	if m.LibraryPanel != nil {
		attr_librarypanel = m.LibraryPanel
	}
	var attr_options interface{}
	if m.Options != nil {
		attr_options = m.Options
	}
	var attr_fieldconfig interface{}
	if m.FieldConfig != nil {
		attr_fieldconfig = m.FieldConfig
	}

	model := &jsonPanelGeomapDataSourceModel{
		Type:            attr_type,
		PluginVersion:   &attr_pluginversion,
		Tags:            attr_tags,
		Targets:         attr_targets,
		Title:           &attr_title,
		Description:     &attr_description,
		Transparent:     attr_transparent,
		Datasource:      attr_datasource,
		GridPos:         attr_gridpos,
		Links:           attr_links,
		Repeat:          &attr_repeat,
		RepeatDirection: attr_repeatdirection,
		RepeatPanelId:   &attr_repeatpanelid,
		MaxDataPoints:   &attr_maxdatapoints,
		Transformations: attr_transformations,
		Interval:        &attr_interval,
		TimeFrom:        &attr_timefrom,
		TimeShift:       &attr_timeshift,
		LibraryPanel:    attr_librarypanel,
		Options:         attr_options,
		FieldConfig:     attr_fieldconfig,
	}
	return json.Marshal(model)
}

func (m PanelGeomapDataSourceModel) ApplyDefaults() PanelGeomapDataSourceModel {
	if m.Type.IsNull() {
		m.Type = types.StringValue(`geomap`)
	}
	if len(m.Tags.Elements()) == 0 {
		m.Tags, _ = types.ListValue(types.StringType, []attr.Value{})
	}
	if len(m.Targets.Elements()) == 0 {
		m.Targets, _ = types.ListValue(types.StringType, []attr.Value{})
	}
	if m.Transparent.IsNull() {
		m.Transparent = types.BoolValue(false)
	}
	if m.RepeatDirection.IsNull() {
		m.RepeatDirection = types.StringValue(`h`)
	}
	return m
}

func (d *PanelGeomapDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_panel_geomap"
}

func (d *PanelGeomapDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "TODO description",
		Attributes: map[string]schema.Attribute{
			"type": schema.StringAttribute{
				MarkdownDescription: `The panel plugin type id. May not be empty. Defaults to "geomap".`,
				Computed:            true,
				Optional:            true,
				Required:            false,
			},
			"plugin_version": schema.StringAttribute{
				MarkdownDescription: `FIXME this almost certainly has to be changed in favor of scuemata versions`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"tags": schema.ListAttribute{
				MarkdownDescription: `TODO docs`,
				Computed:            false,
				Optional:            true,
				Required:            false,
				ElementType:         types.StringType,
			},
			"targets": schema.ListAttribute{
				MarkdownDescription: `TODO docs`,
				Computed:            false,
				Optional:            true,
				Required:            false,
				ElementType:         types.StringType,
			},
			"title": schema.StringAttribute{
				MarkdownDescription: `Panel title.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: `Description.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"transparent": schema.BoolAttribute{
				MarkdownDescription: `Whether to display the panel without a background. Defaults to false.`,
				Computed:            true,
				Optional:            true,
				Required:            false,
			},
			"datasource": schema.SingleNestedAttribute{
				MarkdownDescription: `The datasource used in all targets.`,
				Computed:            true,
				Optional:            true,
				Required:            false,
				Attributes: map[string]schema.Attribute{
					"type": schema.StringAttribute{
						MarkdownDescription: ``,
						Computed:            false,
						Optional:            true,
						Required:            false,
					},
					"uid": schema.StringAttribute{
						MarkdownDescription: ``,
						Computed:            false,
						Optional:            true,
						Required:            false,
					},
				},
			},
			"grid_pos": schema.SingleNestedAttribute{
				MarkdownDescription: `Grid position.`,
				Computed:            true,
				Optional:            true,
				Required:            false,
				Attributes: map[string]schema.Attribute{
					"h": schema.Int64Attribute{
						MarkdownDescription: `Panel. Defaults to 9.`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"w": schema.Int64Attribute{
						MarkdownDescription: `Panel. Defaults to 12.`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"x": schema.Int64Attribute{
						MarkdownDescription: `Panel x. Defaults to 0.`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"y": schema.Int64Attribute{
						MarkdownDescription: `Panel y. Defaults to 0.`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"static": schema.BoolAttribute{
						MarkdownDescription: `true if fixed`,
						Computed:            false,
						Optional:            true,
						Required:            false,
					},
				},
			},
			"links": schema.ListNestedAttribute{
				MarkdownDescription: `Panel links.
TODO fill this out - seems there are a couple variants?`,
				Computed: false,
				Optional: true,
				Required: false,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"title": schema.StringAttribute{
							MarkdownDescription: ``,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"type": schema.StringAttribute{
							MarkdownDescription: ``,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"icon": schema.StringAttribute{
							MarkdownDescription: ``,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"tooltip": schema.StringAttribute{
							MarkdownDescription: ``,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"url": schema.StringAttribute{
							MarkdownDescription: ``,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"tags": schema.ListAttribute{
							MarkdownDescription: ``,
							Computed:            false,
							Optional:            true,
							Required:            false,
							ElementType:         types.StringType,
						},
						"as_dropdown": schema.BoolAttribute{
							MarkdownDescription: ` Defaults to false.`,
							Computed:            true,
							Optional:            true,
							Required:            false,
						},
						"target_blank": schema.BoolAttribute{
							MarkdownDescription: ` Defaults to false.`,
							Computed:            true,
							Optional:            true,
							Required:            false,
						},
						"include_vars": schema.BoolAttribute{
							MarkdownDescription: ` Defaults to false.`,
							Computed:            true,
							Optional:            true,
							Required:            false,
						},
						"keep_time": schema.BoolAttribute{
							MarkdownDescription: ` Defaults to false.`,
							Computed:            true,
							Optional:            true,
							Required:            false,
						},
					},
				},
			},
			"repeat": schema.StringAttribute{
				MarkdownDescription: `Name of template variable to repeat for.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"repeat_direction": schema.StringAttribute{
				MarkdownDescription: `Direction to repeat in if 'repeat' is set.
"h" for horizontal, "v" for vertical.
TODO this is probably optional. Defaults to "h".`,
				Computed: true,
				Optional: true,
				Required: false,
			},
			"repeat_panel_id": schema.Int64Attribute{
				MarkdownDescription: `Id of the repeating panel.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"max_data_points": schema.Float64Attribute{
				MarkdownDescription: `TODO docs`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"transformations": schema.ListNestedAttribute{
				MarkdownDescription: ``,
				Computed:            false,
				Optional:            true,
				Required:            false,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"disabled": schema.BoolAttribute{
							MarkdownDescription: `Disabled transformations are skipped`,
							Computed:            false,
							Optional:            true,
							Required:            false,
						},
						"filter": schema.SingleNestedAttribute{
							MarkdownDescription: `Optional frame matcher.  When missing it will be applied to all results`,
							Computed:            true,
							Optional:            true,
							Required:            false,
						},
					},
				},
			},
			"interval": schema.StringAttribute{
				MarkdownDescription: `TODO docs
TODO tighter constraint`,
				Computed: false,
				Optional: true,
				Required: false,
			},
			"time_from": schema.StringAttribute{
				MarkdownDescription: `TODO docs
TODO tighter constraint`,
				Computed: false,
				Optional: true,
				Required: false,
			},
			"time_shift": schema.StringAttribute{
				MarkdownDescription: `TODO docs
TODO tighter constraint`,
				Computed: false,
				Optional: true,
				Required: false,
			},
			"library_panel": schema.SingleNestedAttribute{
				MarkdownDescription: `Dynamically load the panel`,
				Computed:            true,
				Optional:            true,
				Required:            false,
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: ``,
						Computed:            false,
						Optional:            false,
						Required:            true,
					},
					"uid": schema.StringAttribute{
						MarkdownDescription: ``,
						Computed:            false,
						Optional:            false,
						Required:            true,
					},
				},
			},
			"options": schema.SingleNestedAttribute{
				MarkdownDescription: ``,
				Computed:            true,
				Optional:            true,
				Required:            false,
				Attributes: map[string]schema.Attribute{
					"view": schema.SingleNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						Optional:            true,
						Required:            false,
						Attributes: map[string]schema.Attribute{
							"lat": schema.Int64Attribute{
								MarkdownDescription: ` Defaults to 0.`,
								Computed:            true,
								Optional:            true,
								Required:            false,
							},
							"lon": schema.Int64Attribute{
								MarkdownDescription: ` Defaults to 0.`,
								Computed:            true,
								Optional:            true,
								Required:            false,
							},
							"zoom": schema.Int64Attribute{
								MarkdownDescription: ` Defaults to 1.`,
								Computed:            true,
								Optional:            true,
								Required:            false,
							},
							"min_zoom": schema.Int64Attribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"max_zoom": schema.Int64Attribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"padding": schema.Int64Attribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"all_layers": schema.BoolAttribute{
								MarkdownDescription: ` Defaults to true.`,
								Computed:            true,
								Optional:            true,
								Required:            false,
							},
							"last_only": schema.BoolAttribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"layer": schema.StringAttribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"shared": schema.BoolAttribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
						},
					},
					"controls": schema.SingleNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						Optional:            true,
						Required:            false,
						Attributes: map[string]schema.Attribute{
							"show_zoom": schema.BoolAttribute{
								MarkdownDescription: `Zoom (upper left)`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"mouse_wheel_zoom": schema.BoolAttribute{
								MarkdownDescription: `let the mouse wheel zoom`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"show_attribution": schema.BoolAttribute{
								MarkdownDescription: `Lower right`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"show_scale": schema.BoolAttribute{
								MarkdownDescription: `Scale options`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"show_debug": schema.BoolAttribute{
								MarkdownDescription: `Show debug`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"show_measure": schema.BoolAttribute{
								MarkdownDescription: `Show measure`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
						},
					},
					"basemap": schema.SingleNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						Optional:            true,
						Required:            false,
						Attributes: map[string]schema.Attribute{
							"type": schema.StringAttribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            false,
								Required:            true,
							},
							"name": schema.StringAttribute{
								MarkdownDescription: `configured unique display name`,
								Computed:            false,
								Optional:            false,
								Required:            true,
							},
							"location": schema.SingleNestedAttribute{
								MarkdownDescription: `Common method to define geometry fields`,
								Computed:            true,
								Optional:            true,
								Required:            false,
								Attributes: map[string]schema.Attribute{
									"mode": schema.StringAttribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            false,
										Required:            true,
									},
									"geohash": schema.StringAttribute{
										MarkdownDescription: `Field mappings`,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"latitude": schema.StringAttribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"longitude": schema.StringAttribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"wkt": schema.StringAttribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"lookup": schema.StringAttribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"gazetteer": schema.StringAttribute{
										MarkdownDescription: `Path to Gazetteer`,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
								},
							},
							"opacity": schema.Int64Attribute{
								MarkdownDescription: `Common properties:
https://openlayers.org/en/latest/apidoc/module-ol_layer_Base-BaseLayer.html
Layer opacity (0-1)`,
								Computed: false,
								Optional: true,
								Required: false,
							},
							"tooltip": schema.BoolAttribute{
								MarkdownDescription: `Check tooltip (defaults to true)`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
						},
					},
					"layers": schema.ListNestedAttribute{
						MarkdownDescription: ``,
						Computed:            false,
						Optional:            true,
						Required:            false,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"type": schema.StringAttribute{
									MarkdownDescription: ``,
									Computed:            false,
									Optional:            false,
									Required:            true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: `configured unique display name`,
									Computed:            false,
									Optional:            false,
									Required:            true,
								},
								"location": schema.SingleNestedAttribute{
									MarkdownDescription: `Common method to define geometry fields`,
									Computed:            true,
									Optional:            true,
									Required:            false,
									Attributes: map[string]schema.Attribute{
										"mode": schema.StringAttribute{
											MarkdownDescription: ``,
											Computed:            false,
											Optional:            false,
											Required:            true,
										},
										"geohash": schema.StringAttribute{
											MarkdownDescription: `Field mappings`,
											Computed:            false,
											Optional:            true,
											Required:            false,
										},
										"latitude": schema.StringAttribute{
											MarkdownDescription: ``,
											Computed:            false,
											Optional:            true,
											Required:            false,
										},
										"longitude": schema.StringAttribute{
											MarkdownDescription: ``,
											Computed:            false,
											Optional:            true,
											Required:            false,
										},
										"wkt": schema.StringAttribute{
											MarkdownDescription: ``,
											Computed:            false,
											Optional:            true,
											Required:            false,
										},
										"lookup": schema.StringAttribute{
											MarkdownDescription: ``,
											Computed:            false,
											Optional:            true,
											Required:            false,
										},
										"gazetteer": schema.StringAttribute{
											MarkdownDescription: `Path to Gazetteer`,
											Computed:            false,
											Optional:            true,
											Required:            false,
										},
									},
								},
								"opacity": schema.Int64Attribute{
									MarkdownDescription: `Common properties:
https://openlayers.org/en/latest/apidoc/module-ol_layer_Base-BaseLayer.html
Layer opacity (0-1)`,
									Computed: false,
									Optional: true,
									Required: false,
								},
								"tooltip": schema.BoolAttribute{
									MarkdownDescription: `Check tooltip (defaults to true)`,
									Computed:            false,
									Optional:            true,
									Required:            false,
								},
							},
						},
					},
					"tooltip": schema.SingleNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						Optional:            true,
						Required:            false,
						Attributes: map[string]schema.Attribute{
							"mode": schema.StringAttribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            false,
								Required:            true,
							},
						},
					},
				},
			},
			"field_config": schema.SingleNestedAttribute{
				MarkdownDescription: ``,
				Computed:            true,
				Optional:            true,
				Required:            false,
				Attributes: map[string]schema.Attribute{
					"defaults": schema.SingleNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						Optional:            true,
						Required:            false,
						Attributes: map[string]schema.Attribute{
							"display_name": schema.StringAttribute{
								MarkdownDescription: `The display value for this field.  This supports template variables blank is auto`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"display_name_from_ds": schema.StringAttribute{
								MarkdownDescription: `This can be used by data sources that return and explicit naming structure for values and labels
When this property is configured, this value is used rather than the default naming strategy.`,
								Computed: false,
								Optional: true,
								Required: false,
							},
							"description": schema.StringAttribute{
								MarkdownDescription: `Human readable field metadata`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"path": schema.StringAttribute{
								MarkdownDescription: `An explicit path to the field in the datasource.  When the frame meta includes a path,
This will default to ${frame.meta.path}/${field.name}

When defined, this value can be used as an identifier within the datasource scope, and
may be used to update the results`,
								Computed: false,
								Optional: true,
								Required: false,
							},
							"writeable": schema.BoolAttribute{
								MarkdownDescription: `True if data source can write a value to the path.  Auth/authz are supported separately`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"filterable": schema.BoolAttribute{
								MarkdownDescription: `True if data source field supports ad-hoc filters`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"unit": schema.StringAttribute{
								MarkdownDescription: `Numeric Options`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"decimals": schema.Float64Attribute{
								MarkdownDescription: `Significant digits (for display)`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"min": schema.Float64Attribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"max": schema.Float64Attribute{
								MarkdownDescription: ``,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"thresholds": schema.SingleNestedAttribute{
								MarkdownDescription: `Map numeric values to states`,
								Computed:            true,
								Optional:            true,
								Required:            false,
								Attributes: map[string]schema.Attribute{
									"mode": schema.StringAttribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            false,
										Required:            true,
									},
									"steps": schema.ListNestedAttribute{
										MarkdownDescription: `Must be sorted by 'value', first value is always -Infinity`,
										Computed:            false,
										Optional:            true,
										Required:            false,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"value": schema.Float64Attribute{
													MarkdownDescription: `TODO docs
FIXME the corresponding typescript field is required/non-optional, but nulls currently appear here when serializing -Infinity to JSON`,
													Computed: false,
													Optional: true,
													Required: false,
												},
												"color": schema.StringAttribute{
													MarkdownDescription: `TODO docs`,
													Computed:            false,
													Optional:            false,
													Required:            true,
												},
												"state": schema.StringAttribute{
													MarkdownDescription: `TODO docs
TODO are the values here enumerable into a disjunction?
Some seem to be listed in typescript comment`,
													Computed: false,
													Optional: true,
													Required: false,
												},
											},
										},
									},
								},
							},
							"color": schema.SingleNestedAttribute{
								MarkdownDescription: `Map values to a display color`,
								Computed:            true,
								Optional:            true,
								Required:            false,
								Attributes: map[string]schema.Attribute{
									"mode": schema.StringAttribute{
										MarkdownDescription: `The main color scheme mode`,
										Computed:            false,
										Optional:            false,
										Required:            true,
									},
									"fixed_color": schema.StringAttribute{
										MarkdownDescription: `Stores the fixed color value if mode is fixed`,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"series_by": schema.StringAttribute{
										MarkdownDescription: `Some visualizations need to know how to assign a series color from by value color schemes`,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
								},
							},
							"no_value": schema.StringAttribute{
								MarkdownDescription: `Alternative to empty string`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"custom": schema.SingleNestedAttribute{
								MarkdownDescription: ``,
								Computed:            true,
								Optional:            true,
								Required:            false,
							},
						},
					},
					"overrides": schema.ListNestedAttribute{
						MarkdownDescription: ``,
						Computed:            false,
						Optional:            true,
						Required:            false,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"matcher": schema.SingleNestedAttribute{
									MarkdownDescription: ``,
									Computed:            true,
									Optional:            true,
									Required:            false,
								},
								"properties": schema.ListNestedAttribute{
									MarkdownDescription: ``,
									Computed:            false,
									Optional:            true,
									Required:            false,
								},
							},
						},
					},
				},
			},

			"to_json": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "This datasource rendered as JSON",
			},
		},
	}
}

func (d *PanelGeomapDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
}

func (d *PanelGeomapDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var data PanelGeomapDataSourceModel

	// Read Terraform configuration data into the model
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	JSONConfig, err := json.Marshal(data)
	if err != nil {
		resp.Diagnostics.AddError("JSON marshalling error", err.Error())
		return
	}

	// fix up the targets Attribute
	// Read into a map[string]interface{} and then marshal it back to JSON
	// This is a workaround for the fact that the targets attribute should be a list of maps but is a list of json strings
	dataMap := make(map[string]interface{})
	err = json.Unmarshal(JSONConfig, &dataMap)
	if err != nil {
		resp.Diagnostics.AddError("error unmarshalling config into Go map", err.Error())
		return
	}
	targets := data.Targets.Elements()
	targetsMaps := make([]map[string]interface{}, len(targets))
	for i, target := range targets {
		targetMap := make(map[string]interface{})
		err = json.Unmarshal([]byte(target.(types.String).ValueString()), &targetMap)
		if err != nil {
			resp.Diagnostics.AddError("error unmarshalling target into go map", err.Error())
			return
		}
		targetsMaps[i] = targetMap
	}

	dataMap["targets"] = targetsMaps
	JSONConfig, err = json.MarshalIndent(dataMap, "", "  ")
	if err != nil {
		resp.Diagnostics.AddError("error marshalling go map into json", err.Error())
		return
	}

	// Not sure about that
	data.ToJSON = types.StringValue(string(JSONConfig))

	// Write logs using the tflog package
	// Documentation: https://terraform.io/plugin/log
	tflog.Trace(ctx, "read a data source")

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}
